<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nuclex.Support</name>
    </assembly>
    <members>
        <member name="T:Nuclex.Support.EnumHelper">
            <summary>Helper methods for enumerations</summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelper.GetHighestValue``1">
            <summary>Returns the highest value encountered in an enumeration</summary>
            <typeparam name="TEnum">
              Enumeration of which the highest value will be returned
            </typeparam>
            <returns>The highest value in the enumeration</returns>
        </member>
        <member name="M:Nuclex.Support.EnumHelper.GetLowestValue``1">
            <summary>Returns the lowest value encountered in an enumeration</summary>
            <typeparam name="EnumType">
              Enumeration of which the lowest value will be returned
            </typeparam>
            <returns>The lowest value in the enumeration</returns>
        </member>
        <member name="M:Nuclex.Support.EnumHelper.GetValues``1">
            <summary>Retrieves a list of all values contained in an enumeration</summary>
            <typeparam name="TEnum">
              Type of the enumeration whose values will be returned
            </typeparam>
            <returns>All values contained in the specified enumeration</returns>
            <remarks>
              This method produces collectable garbage so it's best to only call it once
              and cache the result.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.EnumHelper.GetValuesXbox360``1">
            <summary>Retrieves a list of all values contained in an enumeration</summary>
            <typeparam name="TEnum">
              Type of the enumeration whose values will be returned
            </typeparam>
            <returns>All values contained in the specified enumeration</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyCollectionTest">
            <summary>Unit Test for the read only collection wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestCopyConstructor">
            <summary>
              Verifies that the copy constructor of the read only collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestIsReadOnly">
            <summary>Verifies that the IsReadOnly property returns true</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestCopyToArray">
            <summary>
              Verifies that the CopyTo() of the read only collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestContains">
            <summary>
              Checks whether the Contains() method of the read only collection is able to
              determine if the collection contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestThrowOnAdd">
            <summary>
              Ensures that the Add() method of the read only collection throws an exception
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestThrowOnRemove">
            <summary>
              Ensures that the Remove() method of the read only collection throws an exception
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestThrowOnClear">
            <summary>
              Ensures that the Clear() method of the read only collection throws an exception
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestTypesafeEnumerator">
            <summary>
              Tests whether the typesafe enumerator of the read only collection is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestCopyToArrayViaICollection">
            <summary>
              Verifies that the CopyTo() of the read only collection works if invoked via
              the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableCollectionTest">
            <summary>Unit Test for the observable collection class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.Setup">
            <summary>Initialization routine executed before each test is run</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.TestClearingEvent">
            <summary>Tests whether the Clearing event is fired</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.TestItemAddedEvent">
            <summary>Tests whether the ItemAdded event is fired</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.TestItemRemovedEvent">
            <summary>Tests whether the ItemRemoved event is fired</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.TestListConstructor">
            <summary>Tests whether a the list constructor is working</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableCollectionTest.mockery">
            <summary>Mock object factory</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableCollectionTest.mockedSubscriber">
            <summary>The mocked observable collection subscriber</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableCollectionTest.observedCollection">
            <summary>An observable collection to which a mock will be subscribed</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableCollectionTest.IObservableCollectionSubscriber">
            <summary>Interface used to test the observable collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.IObservableCollectionSubscriber.Clearing(System.Object,System.EventArgs)">
            <summary>Called when the collection is about to clear its contents</summary>
            <param name="sender">Collection that is clearing its contents</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.IObservableCollectionSubscriber.Cleared(System.Object,System.EventArgs)">
            <summary>Called when the collection has been cleared of its contents</summary>
            <param name="sender">Collection that was cleared of its contents</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.IObservableCollectionSubscriber.ItemAdded(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.Int32})">
            <summary>Called when an item is added to the collection</summary>
            <param name="sender">Collection to which an item is being added</param>
            <param name="arguments">Contains the item that is being added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.IObservableCollectionSubscriber.ItemRemoved(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.Int32})">
            <summary>Called when an item is removed from the collection</summary>
            <param name="sender">Collection from which an item is being removed</param>
            <param name="arguments">Contains the item that is being removed</param>
        </member>
        <member name="T:Nuclex.Support.Collections.ConstantsTest">
            <summary>Unit Test for the collection constants</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ConstantsTest.CollectionResetEventArgsHaveResetActionSet">
            <summary>
              Verifies that the collection reset event arguments have 'reset' specified as
              their action
            </summary>
        </member>
        <member name="T:Nuclex.Support.IntegerHelperTest">
            <summary>Contains unit tests for the integer helper class</summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelperTest.TestNextPowerOf2ULong">
            <summary>
              Verifies that the next power of 2 calculation works for long integers
            </summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelperTest.TestNextPowerOf2Long">
            <summary>
              Verifies that the next power of 2 calculation works for long integers
            </summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelperTest.TestNextPowerOf2UInt">
            <summary>
              Verifies that the next power of 2 calculation works for integers
            </summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelperTest.TestNextPowerOf2Int">
            <summary>
              Verifies that the next power of 2 calculation works for integers
            </summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelperTest.TestCountBitsInInteger">
            <summary>Verifies that the bit counting method for integers works</summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelperTest.TestCountBitsInLongInteger">
            <summary>Verifies that the bit counting method for long integers works</summary>
        </member>
        <member name="T:Nuclex.Support.IO.ChainStream">
            <summary>Chains a series of independent streams into a single stream</summary>
            <remarks>
              <para>
                This class can be used to chain multiple independent streams into a single
                stream that acts as if its chained streams were only one combined stream.
                It is useful to avoid creating huge memory streams or temporary files when
                you just need to prepend or append some data to a stream or if you need to
                read a file that was split into several parts as if it was a single file.
              </para>
              <para>
                It is not recommended to change the size of any chained stream after it
                has become part of a stream chainer, though the stream chainer will do its
                best to cope with the changes as they occur. Increasing the length of a
                chained stream is generally not an issue for streams that support seeking,
                but reducing the length might invalidate the stream chainer's file pointer,
                resulting in an IOException when Read() or Write() is next called.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.#ctor(System.IO.Stream[])">
            <summary>Initializes a new stream chainer</summary>
            <param name="streams">Array of streams that will be chained together</param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.Flush">
            <summary>
              Clears all buffers for this stream and causes any buffered data to be written
              to the underlying device.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Reads a sequence of bytes from the stream and advances the position of
              the file pointer by the number of bytes read.
            </summary>
            <param name="buffer">Buffer that will receive the data read from the stream</param>
            <param name="offset">
              Offset in the buffer at which the stream will place the data read
            </param>
            <param name="count">Maximum number of bytes that will be read</param>
            <returns>
              The number of bytes that were actually read from the stream and written into
              the provided buffer
            </returns>
            <exception cref="T:System.NotSupportedException">
              The chained stream at the current position does not support reading
            </exception>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Changes the position of the file pointer</summary>
            <param name="offset">
              Offset to move the file pointer by, relative to the position indicated by
              the <paramref name="origin" /> parameter.
            </param>
            <param name="origin">
              Reference point relative to which the file pointer is placed
            </param>
            <returns>The new absolute position within the stream</returns>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length the stream shall have</param>
            <exception cref="T:System.NotSupportedException">
              Always, the stream chainer does not support the SetLength() operation
            </exception>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Writes a sequence of bytes to the stream and advances the position of
              the file pointer by the number of bytes written.
            </summary>
            <param name="buffer">
              Buffer containing the data that will be written to the stream
            </param>
            <param name="offset">
              Offset in the buffer at which the data to be written starts
            </param>
            <param name="count">Number of bytes that will be written into the stream</param>
            <remarks>
              The behavior of this method is as follows: If one or more chained streams
              do not support seeking, all data is appended to the final stream in the
              chain. Otherwise, writing will begin with the stream the current file pointer
              offset falls into. If the end of that stream is reached, writing continues
              in the next stream. On the last stream, writing more data into the stream
              that it current size allows will enlarge the stream.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.moveFilePointer(System.Int64)">
            <summary>Moves the file pointer</summary>
            <param name="position">New position the file pointer will be moved to</param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.findStreamIndexAndOffset(System.Int64,System.Int32@,System.Int64@)">
            <summary>
              Finds the stream index and local offset for an absolute position within
              the combined streams.
            </summary>
            <param name="overallPosition">Absolute position within the combined streams</param>
            <param name="streamIndex">
              Index of the stream the overall position falls into
            </param>
            <param name="streamPosition">
              Local position within the stream indicated by <paramref name="streamIndex" />
            </param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.determineCapabilities">
            <summary>Determines the capabilities of the chained streams</summary>
            <remarks>
              <para>
                Theoretically, it would be possible to create a stream chainer that supported
                writing only when the file pointer was on a chained stream with write support,
                that could seek within the beginning of the stream until the first chained
                stream with no seek capability was encountered and so on.
              </para>
              <para>
                However, the interface of the Stream class requires us to make a definitive
                statement as to whether the Stream supports seeking, reading and writing.
                We can't return "maybe" or "mostly" in CanSeek, so the only sane choice that
                doesn't violate the Stream interface is to implement these capabilities as
                all or nothing - either all streams support a feature, or the stream chainer
                will report the feature as unsupported.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.makeSeekNotSupportedException(System.String)">
            <summary>
              Constructs a NotSupportException for an error caused by one of the chained
              streams having no seek support
            </summary>
            <param name="action">Action that was tried to perform</param>
            <returns>The newly constructed NotSupportedException</returns>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.streams">
            <summary>Streams that have been chained together</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.position">
            <summary>Current position of the overall file pointer</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.activeReadStreamIndex">
            <summary>Stream we're currently reading from if seeking is not supported</summary>
            <remarks>
              If seeking is not supported, the stream chainer will read from each stream
              until the end was reached
              sequentially
            </remarks>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.activeReadStreamPosition">
            <summary>Position in the current read stream if seeking is not supported</summary>
            <remarks>
              If there is a mix of streams supporting seeking and not supporting seeking, we
              need to keep track of the read index for those streams that do. If, for example,
              the last stream is written to and read from in succession, the file pointer
              of that stream would have been moved to the end by the write attempt, skipping
              data that should have been read in the following read attempt.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.allStreamsCanSeek">
            <summary>Whether all of the chained streams support seeking</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.allStreamsCanRead">
            <summary>Whether all of the chained streams support reading</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.allStreamsCanWrite">
            <summary>Whether all of the chained streams support writing</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.CanRead">
            <summary>Whether data can be read from the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.CanSeek">
            <summary>Whether the stream supports seeking</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.CanWrite">
            <summary>Whether data can be written into the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.Length">
            <summary>Length of the stream in bytes</summary>
            <exception cref="T:System.NotSupportedException">
              At least one of the chained streams does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.Position">
            <summary>Absolute position of the file pointer within the stream</summary>
            <exception cref="T:System.NotSupportedException">
              At least one of the chained streams does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.ChainedStreams">
            <summary>Streams being combined by the stream chainer</summary>
        </member>
        <member name="T:Nuclex.Support.IO.PartialStreamTest">
            <summary>Unit Test for the partial stream</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestConstructor">
            <summary>Tests whether the partial stream constructor is working</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnInvalidStartInConstructor">
            <summary>
              Verifies that the partial stream constructor throws an exception if
              it's invoked with an invalid start offset
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnInvalidLengthInConstructor">
            <summary>
              Verifies that the partial stream constructor throws an exception if
              it's invoked with an invalid start offset
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnUnseekableStreamWithOffsetInConstructor">
            <summary>
              Verifies that the partial stream constructor throws an exception if
              it's invoked with a start offset on an unseekable stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestCanReadProperty">
            <summary>
              Tests whether the CanRead property reports its status correctly
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestCanWriteProperty">
            <summary>
              Tests whether the CanWrite property reports its status correctly
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestCanSeekProperty">
            <summary>
              Tests whether the CanSeek property reports its status correctly
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestCompleteStreamProperty">
            <summary>
              Tests whether the CompleteStream property returns the original stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestFlush">
            <summary>Tests whether the Flush() method can be called</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestGetPosition">
            <summary>
              Tests whether the Position property correctly reports the file pointer position
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestSetPosition">
            <summary>
              Tests whether the Position property is correctly updated
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnGetPositionOnUnseekableStream">
            <summary>
              Tests whether the Position property throws an exception if the stream does
              not support seeking.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnSetPositionOnUnseekableStream">
            <summary>
              Tests whether the Position property throws an exception if the stream does
              not support seeking.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnReadFromUnreadableStream">
            <summary>
              Tests whether the Read() method throws an exception if the stream does
              not support reading
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestSeeking">
            <summary>
              Tests whether the Seek() method of the partial stream is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnInvalidSeekReferencePoint">
            <summary>
              Tests whether the Seek() method throws an exception if an invalid
              reference point is provided
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnLengthChange">
            <summary>
              Verifies that the partial stream throws an exception if the attempt is
              made to change the length of the stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestReadFromInvalidPosition">
            <summary>
              Tests whether the Read() method returns 0 bytes if the attempt is made
              to read data from an invalid position
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestReadFromPartialStream">
            <summary>Verifies that the Read() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestWriteToPartialStream">
            <summary>Verifies that the Write() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnExtendPartialStream">
            <summary>
              Verifies that an exception is thrown if the Write() method of the partial stream
              is attempted to be used to extend the partial stream's length
            </summary>
        </member>
        <member name="T:Nuclex.Support.IO.PartialStreamTest.TestStream">
            <summary>Testing stream that allows specific features to be disabled</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.#ctor(System.IO.Stream,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Initializes a new test stream</summary>
            <param name="wrappedStream">Stream that will be wrapped</param>
            <param name="allowRead">Whether to allow reading from the stream</param>
            <param name="allowWrite">Whether to allow writing to the stream</param>
            <param name="allowSeek">Whether to allow seeking within the stream</param>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.Flush">
            <summary>
              Clears all buffers for this stream and causes any buffered data to be written
              to the underlying device.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Reads a sequence of bytes from the stream and advances the position of
              the file pointer by the number of bytes read.
            </summary>
            <param name="buffer">Buffer that will receive the data read from the stream</param>
            <param name="offset">
              Offset in the buffer at which the stream will place the data read
            </param>
            <param name="count">Maximum number of bytes that will be read</param>
            <returns>
              The number of bytes that were actually read from the stream and written into
              the provided buffer
            </returns>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Changes the position of the file pointer</summary>
            <param name="offset">
              Offset to move the file pointer by, relative to the position indicated by
              the <paramref name="origin" /> parameter.
            </param>
            <param name="origin">
              Reference point relative to which the file pointer is placed
            </param>
            <returns>The new absolute position within the stream</returns>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length the stream shall have</param>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Writes a sequence of bytes to the stream and advances the position of
              the file pointer by the number of bytes written.
            </summary>
            <param name="buffer">
              Buffer containing the data that will be written to the stream
            </param>
            <param name="offset">
              Offset in the buffer at which the data to be written starts
            </param>
            <param name="count">Number of bytes that will be written into the stream</param>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.enforceReadAllowed">
            <summary>Throws an exception if reading is not allowed</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.enforceWriteAllowed">
            <summary>Throws an exception if writing is not allowed</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.enforceSeekAllowed">
            <summary>Throws an exception if seeking is not allowed</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStreamTest.TestStream.stream">
            <summary>Stream being wrapped for testing</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStreamTest.TestStream.readAllowed">
            <summary>whether to allow reading from the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStreamTest.TestStream.writeAllowed">
            <summary>Whether to allow writing to the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStreamTest.TestStream.seekAllowed">
            <summary>Whether to allow seeking within the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStreamTest.TestStream.flushCallCount">
            <summary>Number of times the Flush() method has been called</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStreamTest.TestStream.CanRead">
            <summary>Whether data can be read from the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStreamTest.TestStream.CanSeek">
            <summary>Whether the stream supports seeking</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStreamTest.TestStream.CanWrite">
            <summary>Whether data can be written into the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStreamTest.TestStream.Length">
            <summary>Length of the stream in bytes</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStreamTest.TestStream.Position">
            <summary>Absolute position of the file pointer within the stream</summary>
            <exception cref="T:System.NotSupportedException">
              At least one of the chained streams does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStreamTest.TestStream.FlushCallCount">
            <summary>Number of times the Flush() method has been called</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableSet`1">
            <summary>Set which fires events when items are removed or added to it</summary>
            <typeparam name="TItem">Type of items to manage in the set</typeparam>
        </member>
        <member name="T:Nuclex.Support.Collections.IObservableCollection`1">
            <summary>Interface for collections that can be observed</summary>
            <typeparam name="TItem">Type of items managed in the collection</typeparam>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.ItemAdded">
            <summary>Raised when an item has been added to the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.ItemRemoved">
            <summary>Raised when an item is removed from the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.ItemReplaced">
            <summary>Raised when an item is replaced in the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.Clearing">
            <summary>Raised when the collection is about to be cleared</summary>
            <remarks>
              This could be covered by calling ItemRemoved for each item currently
              contained in the collection, but it is often simpler and more efficient
              to process the clearing of the entire collection as a special operation.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.Cleared">
            <summary>Raised when the collection has been cleared of its items</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.#ctor">
            <summary>Initializes a new observable set based on a hashed set</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.#ctor(System.Collections.Generic.ISet{`0})">
            <summary>
              Initializes a new observable set forwarding operations to the specified set
            </summary>
            <param name="set">Set operations will be forwarded to</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.Add(`0)">
            <summary>Adds an item to the set</summary>
            <param name="item">Item that will be added to the set</param>
            <returns>
              True if the element was added, false if it was already contained in the set
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes all elements that are contained in the collection</summary>
            <param name="other">Collection whose elements will be removed from this set</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Only keeps those elements in this set that are contained in the collection
            </summary>
            <param name="other">Other set this set will be filtered by</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Determines whether the current set is a proper (strict) subset of a collection
            </summary>
            <param name="other">Collection against which the set will be tested</param>
            <returns>True if the set is a proper subset of the specified collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Determines whether the current set is a proper (strict) superset of a collection
            </summary>
            <param name="other">Collection against which the set will be tested</param>
            <returns>True if the set is a proper superset of the specified collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a subset of a collection</summary>
            <param name="other">Collection against which the set will be tested</param>
            <returns>True if the set is a subset of the specified collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a superset of a collection</summary>
            <param name="other">Collection against which the set will be tested</param>
            <returns>True if the set is a superset of the specified collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Determines if the set shares at least one common element with the collection
            </summary>
            <param name="other">Collection the set will be tested against</param>
            <returns>
              True if the set shares at least one common element with the collection
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Determines whether the set contains the same elements as the specified collection
            </summary>
            <param name="other">Collection the set will be tested against</param>
            <returns>True if the set contains the same elements as the collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Modifies the current set so that it contains only elements that are present either
              in the current set or in the specified collection, but not both
            </summary>
            <param name="other">Collection the set will be excepted with</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Modifies the current set so that it contains all elements that are present in both
              the current set and in the specified collection
            </summary>
            <param name="other">Collection an union will be built with</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.Clear">
            <summary>Removes all items from the set</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.Contains(`0)">
            <summary>Determines whether the set contains the specified item</summary>
            <param name="item">Item the set will be tested for</param>
            <returns>True if the set contains the specified item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the set into an array</summary>
            <param name="array">Array the set's contents will be copied to</param>
            <param name="arrayIndex">
              Index in the array the first copied element will be written to
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.Remove(`0)">
            <summary>Removes an item from the set</summary>
            <param name="item">Item that will be removed from the set</param>
            <returns>
              True if the item was contained in the set and is now removed
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.GetEnumerator">
            <summary>Creates an enumerator for the set's contents</summary>
            <returns>A new enumerator for the sets contents</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.OnAdded(`0)">
            <summary>Fires the 'ItemAdded' event</summary>
            <param name="item">Item that has been added to the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.OnRemoved(`0)">
            <summary>Fires the 'ItemRemoved' event</summary>
            <param name="item">Item that has been removed from the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.OnClearing">
            <summary>Fires the 'Clearing' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.OnCleared">
            <summary>Fires the 'Cleared' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.System#Collections#Generic#ICollection{TItem}#Add(`0)">
            <summary>Adds an item to the set</summary>
            <param name="item">Item that will be added to the set</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSet`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Creates an enumerator for the set's contents</summary>
            <returns>A new enumerator for the sets contents</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableSet`1.set">
            <summary>The set being wrapped</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableSet`1.ItemAdded">
            <summary>Raised when an item has been added to the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableSet`1.ItemRemoved">
            <summary>Raised when an item is removed from the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableSet`1.ItemReplaced">
            <summary>Raised when an item is replaced in the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableSet`1.Clearing">
            <summary>Raised when the collection is about to be cleared</summary>
            <remarks>
              This could be covered by calling ItemRemoved for each item currently
              contained in the collection, but it is often simpler and more efficient
              to process the clearing of the entire collection as a special operation.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableSet`1.Cleared">
            <summary>Raised when the collection has been cleared</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableSet`1.CollectionChanged">
            <summary>Called when the collection has changed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableSet`1.Count">
            <summary>Counts the number of items contained in the set</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableSet`1.IsReadOnly">
            <summary>Determines whether the set is readonly</summary>
        </member>
        <member name="T:Nuclex.Support.IO.RingMemoryStream">
            <summary>Specialized memory stream for ring buffers</summary>
            <remarks>
              This ring buffer class is specialized for binary data and tries to achieve
              optimal efficiency when storing and retrieving chunks of several bytes
              at once. Typical use cases include audio and network buffers where one party
              is responsible for refilling the buffer at regular intervals while the other
              constantly streams data out of it.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.#ctor(System.Int32)">
            <summary>Initializes a new ring memory stream</summary>
            <param name="capacity">Maximum capacity of the stream</param>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.Flush">
            <summary>Flushes the buffers and writes down unsaved data</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>Reads data from the beginning of the stream</summary>
            <param name="buffer">Buffer in which to store the data</param>
            <param name="offset">Starting index at which to begin writing the buffer</param>
            <param name="count">Number of bytes to read from the stream</param>
            <returns>Die Number of bytes actually read</returns>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>Appends data to the end of the stream</summary>
            <param name="buffer">Buffer containing the data to append</param>
            <param name="offset">Starting index of the data in the buffer</param>
            <param name="count">Number of bytes to write to the stream</param>
            <exception cref="T:System.OverflowException">When the ring buffer is full</exception>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Jumps to the specified location within the stream</summary>
            <param name="offset">Position to jump to</param>
            <param name="origin">Origin towards which to interpret the offset</param>
            <returns>The new offset within the stream</returns>
            <exception cref="T:System.NotSupportedException">Always</exception>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length to resize the stream to</param>
            <exception cref="T:System.NotSupportedException">Always</exception>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.setEmpty">
            <summary>Resets the stream to its empty state</summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStream.ringBuffer">
            <summary>Internal stream containing the ring buffer data</summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStream.startIndex">
            <summary>Start index of the data within the ring buffer</summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStream.endIndex">
            <summary>End index of the data within the ring buffer</summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStream.empty">
            <summary>Whether the ring buffer is empty</summary>
            <remarks>
              This field is required to differentiate between the ring buffer being
              filled to the limit and being totally empty, because in both cases,
              the start index and the end index will be the same. 
            </remarks>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.Capacity">
            <summary>Maximum amount of data that will fit into the ring memory stream</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Thrown if the new capacity is too small for the data already contained
              in the ring buffer.
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.CanRead">
            <summary>Whether it's possible to read from this stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.CanSeek">
            <summary>Whether this stream supports random access</summary>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.CanWrite">
            <summary>Whether it's possible to write into this stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.Length">
            <summary>Current length of the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.Position">
            <summary>Current cursor position within the stream</summary>
            <exception cref="T:System.NotSupportedException">Always</exception>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityItemPairTest">
            <summary>Unit Test for the Priority/Item pair class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPairTest.TestDefaultConstructor">
            <summary>Tests whether the pair's default constructor works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPairTest.TestPriorityRetrieval">
            <summary>Tests whether the priority can be retrieved from the pair</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPairTest.TestItemRetrieval">
            <summary>Tests whether the item can be retrieved from the pair</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPairTest.TestToStringWithValidStrings">
            <summary>Tests whether the ToString() methods works with valid strings</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPairTest.TestToStringWithNullStrings">
            <summary>Tests whether the ToString() methods works with null strings</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityItemPairTest.ToStringNullReturner">
            <summary>Test class in which ToString() can return null</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPairTest.ToStringNullReturner.ToString">
            <summary>
              Returns a System.String that represents the current System.Object
            </summary>
            <returns>A System.String that represents the current System.Object</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableListTest">
            <summary>Unit Test for the observable list class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableListTest.Setup">
            <summary>Initialization routine executed before each test is run</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableListTest.TestClearingEvent">
            <summary>Tests whether the Clearing event is fired</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableListTest.TestItemAddedEvent">
            <summary>Tests whether the ItemAdded event is fired</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableListTest.TestItemRemovedEvent">
            <summary>Tests whether the ItemRemoved event is fired</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableListTest.TestItemReplacement">
            <summary>Tests whether items in the collection can be replaced</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableListTest.TestListConstructor">
            <summary>Tests whether a the list constructor is working</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableListTest.mockery">
            <summary>Mock object factory</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableListTest.mockedSubscriber">
            <summary>The mocked observable collection subscriber</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableListTest.observedList">
            <summary>An observable collection to which a mock will be subscribed</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableListTest.IObservableCollectionSubscriber">
            <summary>Interface used to test the observable collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableListTest.IObservableCollectionSubscriber.Clearing(System.Object,System.EventArgs)">
            <summary>Called when the collection is about to clear its contents</summary>
            <param name="sender">Collection that is clearing its contents</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableListTest.IObservableCollectionSubscriber.Cleared(System.Object,System.EventArgs)">
            <summary>Called when the collection has been cleared of its contents</summary>
            <param name="sender">Collection that was cleared of its contents</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableListTest.IObservableCollectionSubscriber.ItemAdded(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.Int32})">
            <summary>Called when an item is added to the collection</summary>
            <param name="sender">Collection to which an item is being added</param>
            <param name="arguments">Contains the item that is being added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableListTest.IObservableCollectionSubscriber.ItemRemoved(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.Int32})">
            <summary>Called when an item is removed from the collection</summary>
            <param name="sender">Collection from which an item is being removed</param>
            <param name="arguments">Contains the item that is being removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableListTest.IObservableCollectionSubscriber.ItemReplaced(System.Object,Nuclex.Support.Collections.ItemReplaceEventArgs{System.Int32})">
            <summary>Called when an item is replaced in the dictionary</summary>
            <param name="sender">Dictionary in which an item is being replaced</param>
            <param name="arguments">Contains the replaced item and its replacement</param>
        </member>
        <member name="T:Nuclex.Support.Collections.MultiDictionaryTest">
            <summary>Unit tests for the multi dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.CanConstructNewDictionary">
            <summary>
              Verifies that new instances of the multi dictionary can be created
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.CountIsCalculatedIfInitializedFromDictionary">
            <summary>
              Verifies that the count is initialized correctly when building
              a multi dictionary from a dictionary of value collections.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.IsReadOnlyWhenBasedOnReadOnlyContainer">
            <summary>
              Verifies that a new multi dictionary based on a read-only dictionary is
              also read-only
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.CanContainKeyMultipleTimes">
            <summary>
              Ensures that the multi dictionary can contain the same key multiple times
              (or in other words, multiple values on the same key)
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.AddingValuesFromIndexerUpdatesCount">
            <summary>
              Verifies that adding values through the indexer still updates the item count
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.ValuesWithSameKeyCanBeCounted">
            <summary>
              Tests whether the collection can count the number of values stored
              under a key
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.CountingValuesOfNonExistentKeyReturnsNull">
            <summary>
              Verifies that counting the values of a non-existing key returns 0
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.ValuesCanBeRemovedIndividually">
            <summary>
              Ensures that its possible to remove values individually without affecting
              other values stored under the same key
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.CollectionOfCollectionCountIsUniqueKeyCount">
            <summary>
              Verifies that the Count property returns the number of unique keys if it is called
              on the collection-of-collections interface implemented by the multi dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.ContainmentCanBeTested">
            <summary>
              Verifies that the multi dictionary can be tested for containment of a specific value
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.KeyContainmentCanBeTested">
            <summary>
              Verifies that the multi dictionary can be tested for containment of a specific key
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.KeyCollectionCanBeRetrieved">
            <summary>
              Verifies that the key collection can be retrieved from the dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.ValueCollectionCanBeRetrieved">
            <summary>
              Verifies that the key collection can be retrieved from the dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.TryGetValueReturnsFalseOnMissingKey">
            <summary>
              Verifies that TryGetValue() returns false and doesn't throw if a key
              is not found in the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.TryGetValueCanLookUpValues">
            <summary>Verifies that keys can be looked up via TryGetValue()</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.AssigningNullToKeyRemovesAllValues">
            <summary>
              Verifies that assigning null to a key deletes all the values stored
              under it
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.ValueListCanBeAssignedToNewKey">
            <summary>
              Verifies that assigning null to a key deletes all the values stored
              under it
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.ValueListCanOverwriteExistingKey">
            <summary>
              Verifies that assigning null to a key deletes all the values stored
              under it
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.NonExistingKeyCanBeRemoved">
            <summary>
              Verifies that nothing bad happens when a key is removed from the dictionary
              that it doesn't contain
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.RemoveReturnsNumberOfValuesRemoved">
            <summary>
              Verifies that the remove method returns the number of values that have
              been removed from the dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.DictionaryIsEmptyAfterClear">
            <summary>
              Verifies that the dictionary becomes empty after clearing it
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.NonExistingValueCanBeRemoved">
            <summary>
              Verifies that non-existing values can be removed from the dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.LastValueOfKeyCanBeRemoved">
            <summary>
              Verifies that nothing bad happens when the last value under a key is removed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionaryTest.DictionaryCanBeCopiedIntoArray">
            <summary>
              Verifies that the dictionary can be copied into an array
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.MultiDictionary`2">
            <summary>Dictionary that can contain multiple values under the same key</summary>
            <typeparam name="TKey">Type of keys used within the dictionary</typeparam>
            <typeparam name="TValue">Type of values used within the dictionary</typeparam>
        </member>
        <member name="T:Nuclex.Support.Collections.IMultiDictionary`2">
            <summary>
              Associative collection that can store several values under one key and vice versa
            </summary>
            <typeparam name="TKey">Type of keys used within the dictionary</typeparam>
            <typeparam name="TValue">Type of values stored in the dictionary</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.IMultiDictionary`2.Add(`0,`1)">
            <summary>Adds a value into the dictionary under the provided key</summary>
            <param name="key">Key the value will be stored under</param>
            <param name="value">Value that will be stored under the specified key</param>
        </member>
        <member name="M:Nuclex.Support.Collections.IMultiDictionary`2.CountValues(`0)">
            <summary>Determines the number of values stored under the specified key</summary>
            <param name="key">Key whose values will be counted</param>
            <returns>The number of values stored under the specified key</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.IMultiDictionary`2.Remove(`0,`1)">
            <summary>
              Removes the item with the specified key and value from the dictionary
            </summary>
            <param name="key">Key of the item that will be removed</param>
            <param name="value">Value of the item that will be removed</param>
            <returns>
              True if the specified item was contained in the dictionary and was removed
            </returns>
            <exception cref="T:System.NotSupportedException">If the dictionary is read-only</exception>
        </member>
        <member name="M:Nuclex.Support.Collections.IMultiDictionary`2.RemoveKey(`0)">
            <summary>Removes all items with the specified key from the dictionary</summary>
            <param name="key">Key of the item that will be removed</param>
            <returns>The number of items that have been removed from the dictionary</returns>
            <exception cref="T:System.NotSupportedException">If the dictionary is read-only</exception>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.#ctor">
            <summary>Initializes a new multi dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,System.Collections.Generic.ICollection{`1}})">
            <summary>Initializes a new multi dictionary</summary>
            <param name="dictionary">Dictionary the multi dictionary will be based on</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.CountValues(`0)">
            <summary>Determines the number of values stored under the specified key</summary>
            <param name="key">Key whose values will be counted</param>
            <returns>The number of values stored under the specified key</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
              Determines whether the specified KeyValuePair is contained in the dictionary
            </summary>
            <param name="item">KeyValuePair that will be checked for</param>
            <returns>True if the provided KeyValuePair was contained in the dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the Dictionary contains the specified key</summary>
            <param name="key">Key that will be checked for</param>
            <returns>
              True if an entry with the specified key was contained in the Dictionary
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.GetEnumerator">
            <summary>Creates a new enumerator for the dictionary</summary>
            <returns>The new dictionary enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.TryGetValue(`0,System.Collections.Generic.ICollection{`1}@)">
            <summary>
              Attempts to retrieve the item with the specified key from the dictionary
            </summary>
            <param name="key">Key of the item to attempt to retrieve</param>
            <param name="values">
              Output parameter that will receive the values upon successful completion
            </param>
            <returns>
              True if the item was found and has been placed in the output parameter
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.Add(`0,`1)">
            <summary>Inserts an item into the dictionary</summary>
            <param name="key">Key under which to add the new item</param>
            <param name="value">Item that will be added to the dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.Remove(`0,`1)">
            <summary>
              Removes the item with the specified key and value from the dictionary
            </summary>
            <param name="key">Key of the item that will be removed</param>
            <param name="value">Value of the item that will be removed</param>
            <returns>
              True if the specified item was contained in the dictionary and was removed
            </returns>
            <exception cref="T:System.NotSupportedException">If the dictionary is read-only</exception>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.RemoveKey(`0)">
            <summary>Removes all items with the specified key from the dictionary</summary>
            <param name="key">Key of the item that will be removed</param>
            <returns>The number of items that have been removed from the dictionary</returns>
            <exception cref="T:System.NotSupportedException">If the dictionary is read-only</exception>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.typedDictionary">
            <summary>The wrapped Dictionary under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.objectDictionary">
            <summary>The wrapped Dictionary under its object interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.count">
            <summary>The number of items currently in the multi dictionary</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.valueCollection">
            <summary>Provides the values stores in the dictionary in sequence</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new object enumerator for the Dictionary</summary>
            <returns>The new object enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>Adds an item into the dictionary</summary>
            <param name="key">Key under which the item will be added</param>
            <param name="value">Item that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>Determines whether the specified key exists in the dictionary</summary>
            <param name="key">Key that will be checked for</param>
            <returns>True if an item with the specified key exists in the dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>Removes an item from the dictionary</summary>
            <param name="key">Key of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>Returns a new entry enumerator for the dictionary</summary>
            <returns>The new entry enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Inserts an already prepared element into the dictionary</summary>
            <param name="item">Prepared element that will be added to the dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Removes all items from the dictionary</summary>
            <param name="itemToRemove">Item that will be removed from the dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary contents will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#Generic#IDictionary{TKey@System#Collections#Generic#ICollection{TValue}}#Add(`0,System.Collections.Generic.ICollection{`1})">
            <summary>Adds a series of values to a dictionary</summary>
            <param name="key">Key under which the values will be added</param>
            <param name="values">Values that will be added to the dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#Generic#IDictionary{TKey@System#Collections#Generic#ICollection{TValue}}#Remove(`0)">
            <summary>Removes all values with the specified key</summary>
            <param name="key">Key whose associated entries will be removed</param>
            <returns>True if at least one entry has been removed from the dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@System#Collections#Generic#ICollection{TValue}}}#Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
            <summary>Adds a series of values to a dictionary</summary>
            <param name="item">Entry containing the values that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@System#Collections#Generic#ICollection{TValue}}}#Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
            <summary>
              Checks whether the dictionary contains the specified key/value pair
            </summary>
            <param name="item">Key/value pair for which the dictionary will be checked</param>
            <returns>True if the dictionary contains the specified key/value pair</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@System#Collections#Generic#ICollection{TValue}}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}}[],System.Int32)">
            <summary>Copies the contents of the dictionary into an array</summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@System#Collections#Generic#ICollection{TValue}}}#Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
            <summary>Removes the specified key/value pair from the dictionary</summary>
            <param name="item">Key/value pair that will be removed</param>
            <returns>True if the key/value pair was contained in the dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey@System#Collections#Generic#ICollection{TValue}}}#GetEnumerator">
            <summary>Returns an enumerator for the dictionary</summary>
            <returns>An enumerator for the key/value pairs in the dictionary</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.IsReadOnly">
            <summary>Whether the dictionary is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.Count">
            <summary>Number of elements contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.Keys">
            <summary>Collection of all keys contained in the dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.Values">
            <summary>Collection of all values contained in the dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.Item(`0)">
            <summary>Accesses an item in the dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>Whether the size of the dictionary is fixed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#IDictionary#Keys">
            <summary>Returns a collection of all keys in the dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#IDictionary#Values">
            <summary>Returns a collection of all values stored in the dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>Accesses an item in the dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
            <returns>The item with the specified key</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the Dictionary is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the Dictionary locks</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#Generic#IDictionary{TKey@System#Collections#Generic#ICollection{TValue}}#Values">
            <summary>Returns a collection of value collections</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@System#Collections#Generic#ICollection{TValue}}}#Count">
            <summary>Number of unique keys in the dictionary</summary>
            <remarks>
              <para>
                This Count property returns a different value from the main interface of
                the multi dictionary to stay consistent with the implemented interfaces.
              </para>
              <para>
                If you cast a multi dictionary to a collection of collections, the count
                property of the outer collection should, of course, be the number of inner
                collections it contains (and not the sum of the items contained in all of
                the inner collections).
              </para>
              <para>
                If you use the count property in the main interface of the multi dictionary,
                the value collections are hidden (it behaves as if the key was in the
                dictionary multiple times), so now the sum of all key-value pairs should
                be returned.
              </para>
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Collections.MultiDictionary`2.Enumerator">
            <summary>Enumerates the values stored in a multi dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.#ctor(Nuclex.Support.Collections.MultiDictionary{`0,`1})">
            <summary>Initializes a new multi dictionary enumerator</summary>
            <param name="dictionary">Dictionary that will be enumerated</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.MoveNext">
            <summary>Advances the enumerator to the entry</summary>
            <returns>
              True if there was a next entry, false if the end of the set has been reached
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.Reset">
            <summary>Resets the enumerator to its initial position</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.enforceEnumeratorOnValidPosition">
            <summary>
              Throws an exception if the enumerator is not on a valid position
            </summary>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.dictionary">
            <summary>Dictionary over whose entries the enumerator is enumerating</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.currentCollection">
            <summary>Current key the enumerator is at</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.currentValue">
            <summary>Current value in the current key the enumerator is at</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.Current">
            <summary>The current entry the enumerator is pointing at</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.System#Collections#IEnumerator#Current">
            <summary>The item the enumerator is currently pointing at</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.System#Collections#IDictionaryEnumerator#Entry">
            <summary>The current entry the enumerator is pointing to</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.System#Collections#IDictionaryEnumerator#Key">
            <summary>The current dictionary key</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.Enumerator.System#Collections#IDictionaryEnumerator#Value">
            <summary>The current dictionary value</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.MultiDictionary`2.ValueList">
            <summary>Stores the list of values for a dictionary key</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueList.#ctor(Nuclex.Support.Collections.MultiDictionary{`0,`1})">
            <summary>Initializes a new value list</summary>
            <param name="dictionary">Dictionary the value list belongs to</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueList.ClearItems">
            <summary>Called when the value list is being cleared</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueList.InsertItem(System.Int32,`1)">
            <summary>Called when an item is inserted into the value list</summary>
            <param name="index">Index at which the item is being inserted</param>
            <param name="item">Item that is being inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueList.RemoveItem(System.Int32)">
            <summary>Called when an item is removed from the value list</summary>
            <param name="index">Index at which the item is being removed</param>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.ValueList.dictionary">
            <summary>The dictionary the value list belongs to</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection">
            <summary>
              Provides access to the values stored in a multi dictionary as a collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.#ctor(Nuclex.Support.Collections.MultiDictionary{`0,`1})">
            <summary>Initializes a new multi dictionary value collection</summary>
            <param name="dictionary">Dictionary whose values the collection represents</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.Contains(`1)">
            <summary>Determines whether the collection contains a specific value</summary>
            <param name="item">Value for which the collection will be checked</param>
            <returns>True if the collection contains the specified value</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.CopyTo(`1[],System.Int32)">
            <summary>Copies the contents of the collection into an array</summary>
            <param name="array">Array the collection contents will be copied into</param>
            <param name="arrayIndex">
              Starting index in the array where writing will begin
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.GetEnumerator">
            <summary>Returns a new enumerator for the value collection</summary>
            <returns>A new enumerator for the value collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a non-typesafe enumerator for the collection</summary>
            <returns>The non-typesafe collection enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.System#Collections#Generic#ICollection{TValue}#Add(`1)">
            <summary>Throws a NotSupportedException</summary>
            <param name="item">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.System#Collections#Generic#ICollection{TValue}#Clear">
            <summary>Throws a NotSupportedException</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.System#Collections#Generic#ICollection{TValue}#Contains(`1)">
            <summary>Throws a NotSupportedException</summary>
            <param name="item">Not used</param>
            <returns>Nothing, since the method always throws an exception</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.System#Collections#Generic#ICollection{TValue}#Remove(`1)">
            <summary>Not supported</summary>
            <param name="item">Item that will not be removed</param>
            <returns>Nothing because the method throws an exception</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the collection into an array</summary>
            <param name="array">Array the collection's contents are copied into</param>
            <param name="arrayIndex">
              Starting index in the array where writing will begin
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.dictionary">
            <summary>Dictionary whose values the collection represents</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.dictionaryAsICollection">
            <summary>The dictionary under its ICollection interface</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.Count">
            <summary>The number of values in the collection</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.IsReadOnly">
            <summary>Always true since the value collection is read-only</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the dictionary is thread-safe</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.System#Collections#ICollection#SyncRoot">
            <summary>
              The synchronization root used by the dictionary for thread synchronization
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.Enumerator">
            <summary>Enumerates the values stored in a multi dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.Enumerator.#ctor(System.Collections.Generic.ICollection{System.Collections.Generic.ICollection{`1}})">
            <summary>Initializes a new enumerator</summary>
            <param name="valueCollections">Value collections being enumerated</param>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.Enumerator.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next item</summary>
            <returns>
              True if there was a next item, false if the enumerator reached the end
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.Enumerator.Reset">
            <summary>Resets the enumerator to its initial position</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.Enumerator.valueCollections">
            <summary>Value collections being enumerated</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.Enumerator.currentCollection">
            <summary>The current value collection the enumerator is in</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.Enumerator.currentValue">
            <summary>Current value in the collection the enumerator is in</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.Enumerator.Current">
            <summary>The current value the enumerator is pointing at</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.MultiDictionary`2.ValueCollection.Enumerator.System#Collections#IEnumerator#Current">
            <summary>The current entry the enumerator is pointing at</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.IRecyclable">
            <summary>Allows an object to be returned to its initial state</summary>
            <remarks>
              <para>
                This interface is typically implemented by objects which can be recycled
                in order to avoid the construction overhead of a heavyweight class and to
                eliminate garbage by reusing instances.
              </para>
              <para>
                Recyclable objects should have a parameterless constructor and calling
                their Recycle() method should bring them back into the state they were
                in right after they had been constructed.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.IRecyclable.Recycle">
            <summary>Returns the object to its initial state</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.ReflectionClonerTest">
            <summary>Unit Test for the reflection-based cloner</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.CloneFactoryTest">
            <summary>Base class for unit tests verifying the clone factory</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.CloneFactoryTest.VerifyClone(Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType,Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType,System.Boolean,System.Boolean)">
            <summary>
              Verifies that a cloned object exhibits the expected state for the type of
              clone that has been performed
            </summary>
            <param name="original">Original instance the clone was created from</param>
            <param name="clone">Cloned instance that will be checked for correctness</param>
            <param name="isDeepClone">Whether the cloned instance is a deep clone</param>
            <param name="isPropertyBasedClone">
              Whether a property-based clone was performed
            </param>
        </member>
        <member name="M:Nuclex.Support.Cloning.CloneFactoryTest.VerifyClone(Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType@,Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType@,System.Boolean,System.Boolean)">
            <summary>
              Verifies that a cloned object exhibits the expected state for the type of
              clone that has been performed
            </summary>
            <param name="original">Original instance the clone was created from</param>
            <param name="clone">Cloned instance that will be checked for correctness</param>
            <param name="isDeepClone">Whether the cloned instance is a deep clone</param>
            <param name="isPropertyBasedClone">
              Whether a property-based clone was performed
            </param>
        </member>
        <member name="M:Nuclex.Support.Cloning.CloneFactoryTest.CreateValueType">
            <summary>Creates a value type with random data for testing</summary>
            <returns>A new value type with random data</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.CloneFactoryTest.CreateReferenceType">
            <summary>Creates a reference type with random data for testing</summary>
            <returns>A new reference type with random data</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.CloneFactoryTest.AvoidCompilerWarnings">
            <summary>
              Useless method that avoids a compile warnings due to unused fields
            </summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.CloneFactoryTest.DerivedReferenceType">
            <summary>A derived reference type being used for testing</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.CloneFactoryTest.TestReferenceType">
            <summary>A reference type being used for testing</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.TestReferenceType.TestField">
            <summary>Field holding an integer value for testing</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.TestReferenceType.TestProperty">
            <summary>Property holding an integer value for testing</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.DerivedReferenceType.DerivedField">
            <summary>Field holding an integer value for testing</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.DerivedReferenceType.DerivedProperty">
            <summary>Property holding an integer value for testing</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.CloneFactoryTest.TestValueType">
            <summary>A value type being used for testing</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.TestValueType.TestField">
            <summary>Field holding an integer value for testing</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.TestValueType.TestProperty">
            <summary>Property holding an integer value for testing</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType">
            <summary>A value type containiner other complex types used for testing</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.TestField">
            <summary>Field holding an integer value for testing</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.ValueTypeField">
            <summary>Value type field for testing</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.ReferenceTypeField">
            <summary>Reference type field for testing</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.ReferenceTypeArrayField">
            <summary>An array field of reference types</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.AlwaysNullField">
            <summary>A reference type field that's always null</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.ReadOnlyField">
            <summary>A read-only field</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.DerivedField">
            <summary>Field typed as base class holding a derived instance</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.TestProperty">
            <summary>Property holding an integer value for testing</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.ValueTypeProperty">
            <summary>Value type property for testing</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.ReferenceTypeProperty">
            <summary>Reference type property for testing</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.ReferenceTypeArrayProperty">
            <summary>An array property of reference types</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.AlwaysNullProperty">
            <summary>A reference type property that's always null</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.GetOnlyProperty">
            <summary>A property that only has a getter</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.SetOnlyProperty">
            <summary>A property that only has a setter</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalValueType.DerivedProperty">
            <summary>Field typed as base class holding a derived instance</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType">
            <summary>A value type containiner other complex types used for testing</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.TestField">
            <summary>Field holding an integer value for testing</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.ValueTypeField">
            <summary>Value type field for testing</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.ReferenceTypeField">
            <summary>Reference type field for testing</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.ReferenceTypeArrayField">
            <summary>An array field of reference types</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.AlwaysNullField">
            <summary>A reference type field that's always null</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.ReadOnlyField">
            <summary>A read-only field</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.DerivedField">
            <summary>Field typed as base class holding a derived instance</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.TestProperty">
            <summary>Property holding an integer value for testing</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.ValueTypeProperty">
            <summary>Value type property for testing</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.ReferenceTypeProperty">
            <summary>Reference type property for testing</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.ReferenceTypeArrayProperty">
            <summary>An array property of reference types</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.AlwaysNullProperty">
            <summary>A reference type property that's always null</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.GetOnlyProperty">
            <summary>A property that only has a getter</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.SetOnlyProperty">
            <summary>A property that only has a setter</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.HierarchicalReferenceType.DerivedProperty">
            <summary>Field typed as base class holding a derived instance</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.CloneFactoryTest.ClassWithoutDefaultConstructor">
            <summary>A class that does not have a default constructor</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.CloneFactoryTest.ClassWithoutDefaultConstructor.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the class without default constructor
            </summary>
            <param name="dummy">Dummy value that will be saved by the instance</param>
        </member>
        <member name="F:Nuclex.Support.Cloning.CloneFactoryTest.ClassWithoutDefaultConstructor.dummy">
            <summary>Dummy value that has been saved by the instance</summary>
        </member>
        <member name="P:Nuclex.Support.Cloning.CloneFactoryTest.ClassWithoutDefaultConstructor.Dummy">
            <summary>Dummy value that has been saved by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.#ctor">
            <summary>Initializes a new unit test suite for the reflection cloner</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.CloningNullYieldsNull">
            <summary>Verifies that cloning a null object simply returns null</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.ClassWithoutDefaultConstructorCanBeCloned">
            <summary>
              Verifies that clones of objects whose class doesn't possess a default constructor
              can be made
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.PrimitiveTypesCanBeCloned">
            <summary>Verifies that clones of primitive types can be created</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.ShallowClonesOfArraysCanBeMade">
            <summary>Verifies that shallow clones of arrays can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.DeepClonesOfArraysCanBeMade">
            <summary>Verifies that deep clones of arrays can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.GenericListsCanBeCloned">
            <summary>Verifies that deep clones of a generic list can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.GenericDictionariesCanBeCloned">
            <summary>Verifies that deep clones of a generic dictionary can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.ShallowFieldBasedClonesOfValueTypesCanBeMade">
            <summary>
              Verifies that a field-based shallow clone of a value type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.ShallowFieldBasedClonesOfReferenceTypesCanBeMade">
            <summary>
              Verifies that a field-based shallow clone of a reference type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.DeepFieldBasedClonesOfValueTypesCanBeMade">
            <summary>
              Verifies that a field-based deep clone of a value type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.DeepFieldBasedClonesOfReferenceTypesCanBeMade">
            <summary>
              Verifies that a field-based deep clone of a reference type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.ShallowPropertyBasedClonesOfValueTypesCanBeMade">
            <summary>
              Verifies that a property-based shallow clone of a value type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.ShallowPropertyBasedClonesOfReferenceTypesCanBeMade">
            <summary>
              Verifies that a property-based shallow clone of a reference type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.DeepPropertyBasedClonesOfValueTypesCanBeMade">
            <summary>
              Verifies that a property-based deep clone of a value type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionClonerTest.DeepPropertyBasedClonesOfReferenceTypesCanBeMade">
            <summary>
              Verifies that a property-based deep clone of a reference type can be performed
            </summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.ReflectionClonerTest.cloneFactory">
            <summary>Clone factory being tested</summary>
        </member>
        <member name="T:Nuclex.Support.SemaphoreTest">
            <summary>Unit Test for the Semaphore class</summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestReverseCountingConstructor">
            <summary>
              Test whether a semaphore can be initialized with reverse counting
            </summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestLimitConstructor">
            <summary>
              Test whether a semaphore can be initialized with a maximum user count
            </summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestFullConstructor">
            <summary>
              Test whether a semaphore can be initialized with an initial user
              count and a maximum user count
            </summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestThrowOnMoreInitialUsersThanMaximumUsers">
            <summary>
              Verifies that the right exception is thrown if a semaphore is initialized
              with a larger number of initial users than the maximum number of users.
            </summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestWaitTimeout">
            <summary>
              Verifies that the semaphore can time out if the resource does not become
              available within the time limit specified by the user
            </summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestWaitTimeoutWithTimeSpan">
            <summary>
              Verifies that the semaphore can time out if the resource does not become
              available within the time limit specified by the user, if the time limit
              is specified using the TimeSpan class
            </summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestThrowOnWaitWithTooLargeTimeSpan">
            <summary>
              Tests whether an exception is thrown if the WaitOne() method is called
              with a time span that is too large for the underlying synchronization API
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.WeakCollection`1">
            <summary>Collection of weakly referenced objects</summary>
            <remarks>
              This collection tries to expose the interface of a normal collection, but stores
              objects as weak references. When an object is accessed, it can return null.
              when the collection detects that one of its items was garbage collected, it
              will silently remove that item.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>
              A System.Collections.IEnumerator object that can be used to iterate through
              the collection.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the WeakCollection.</summary>
            <param name="value">The System.Object to add to the WeakCollection.</param>
            <returns>The position into which the new element was inserted.</returns>
            <exception cref="T:System.NotSupportedException">
              The System.Collections.IList is read-only or the WeakCollection has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Contains(System.Object)">
            <summary>
              Determines whether the WeakCollection contains a specific value.
            </summary>
            <param name="value">The System.Object to locate in the WeakCollection.</param>
            <returns>
              True if the System.Object is found in the WeakCollection; otherwise, false.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>Determines the index of a specific item in the WeakCollection.</summary>
            <param name="value">The System.Object to locate in the WeakCollection.</param>
            <returns>
              The index of value if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
              Inserts an item to the WeakCollection at the specified index.
            </summary>
            <param name="index">
              The zero-based index at which value should be inserted.
            </param>
            <param name="value">The System.Object to insert into the WeakCollection.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
            <exception cref="T:System.NotSupportedException">
              The System.Collections.IList is read-only or the WeakCollection has a fixed size.
            </exception>
            <exception cref="T:System.NullReferenceException">
              Value is null reference in the WeakCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Remove(System.Object)">
            <summary>
              Removes the first occurrence of a specific object from the WeakCollection.
            </summary>
            <param name="value">The System.Object to remove from the WeakCollection.</param>
            <exception cref="T:System.NotSupportedException">
              The WeakCollection is read-only or the WeakCollection has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
              Copies the elements of the WeakCollection to an System.Array, starting at
              a particular System.Array index.
            </summary>
            <param name="array">
              The one-dimensional System.Array that is the destination of the elements
              copied from WeakCollection. The System.Array must have zero-based indexing.
            </param>
            <param name="index">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
              Array is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is less than zero.
            </exception>
            <exception cref="T:System.ArgumentException">
              Array is multidimensional or index is equal to or greater than the length
              of array or the number of elements in the source WeakCollection is greater than
              the available space from index to the end of the destination array.
            </exception>
            <exception cref="T:System.InvalidCastException">
              The type of the source WeakCollection cannot be cast automatically to the type of
              the destination array.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.downcastToItemType(System.Object)">
            <summary>
              Downcasts an object reference to a reference to the collection's item type
            </summary>
            <param name="value">Object reference that will be downcast</param>
            <returns>
              The specified object referecne as a reference to the collection's item type
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.#ctor(System.Collections.Generic.IList{Nuclex.Support.WeakReference{`0}})">
            <summary>Initializes a new weak reference collection</summary>
            <param name="items">
              Internal list of weak references that are unpacking when accessed through
              the WeakCollection's interface.
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.#ctor(System.Collections.Generic.IList{Nuclex.Support.WeakReference{`0}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new weak reference collection</summary>
            <param name="items">
              Internal list of weak references that are unpacking when accessed through
              the WeakCollection's interface.
            </param>
            <param name="comparer">
              Comparer used to identify and compare items to each other
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Contains(`0)">
            <summary>
              Determines whether an element is in the WeakCollection
            </summary>
            <param name="item">
              The object to locate in the WeakCollection. The value can be null.
            </param>
            <returns>
              True if value is found in the WeakCollection; otherwise, false.
            </returns>
            <remarks>
              The default implementation of this method is very unoptimized and will
              enumerate all the items in the collection, transforming one after another
              to check whether the transformed item matches the item the user was
              looking for. It is recommended to provide a custom implementation of
              this method, if possible.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
              Copies the entire WeakCollection to a compatible one-dimensional
              System.Array, starting at the specified index of the target array.
            </summary>
            <param name="array">
              The one-dimensional System.Array that is the destination of the elements copied
              from the WeakCollection. The System.Array must have zero-based indexing.
            </param>
            <param name="index">
              The zero-based index in array at which copying begins.
            </param>
            <exception cref="T:System.ArgumentException">
              Index is equal to or greater than the length of array or the number of elements
              in the source WeakCollection is greater than the available space from index to
              the end of the destination array.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is less than zero.
            </exception>
            <exception cref="T:System.ArgumentNullException">
              Array is null.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Clear">
            <summary>Removes all items from the WeakCollection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.GetEnumerator">
            <summary>
              Returns an enumerator that iterates through the WeakCollection.
            </summary>
            <returns>An enumerator or the WeakCollection.</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.IndexOf(`0)">
            <summary>
              Searches for the specified object and returns the zero-based index of the
              first occurrence within the entire WeakCollection.
            </summary>
            <param name="item">
              The object to locate in the WeakCollection. The value can
              be null for reference types.
            </param>
            <returns>
              The zero-based index of the first occurrence of item within the entire
              WeakCollection, if found; otherwise, -1.
            </returns>
            <remarks>
              The default implementation of this method is very unoptimized and will
              enumerate all the items in the collection, transforming one after another
              to check whether the transformed item matches the item the user was
              looking for. It is recommended to provide a custom implementation of
              this method, if possible.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Remove(`0)">
            <summary>
              Removes the first occurrence of a specific object from the WeakCollection.
            </summary>
            <param name="item">The object to remove from the WeakCollection</param>
            <returns>
              True if item was successfully removed from the WeakCollection; otherwise, false.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Add(`0)">
            <summary>Adds an item to the WeakCollection.</summary>
            <param name="item">The object to add to the WeakCollection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Insert(System.Int32,`0)">
            <summary>Inserts an item to the WeakCollection at the specified index.</summary>
            <param name="index">
              The zero-based index at which item should be inserted.
            </param>
            <param name="item">The object to insert into the WeakCollection</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              index is not a valid index in the WeakCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.RemoveAt(System.Int32)">
            <summary>
              Removes the WeakCollection item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the WeakCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.RemoveDeadItems">
            <summary>
              Removes the items that have been garbage collected from the collection
            </summary>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollection`1.items">
            <summary>Weak references to the items contained in the collection</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollection`1.comparer">
            <summary>Used to identify and compare items in the collection</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollection`1.syncRoot">
            <summary>Synchronization root for threaded accesses to this collection</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#IsFixedSize">
            <summary>
              A value indicating whether the WeakCollection has a fixed size.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the WeakCollection
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>
              A value indicating whether access to the WeakCollection is
              synchronized (thread safe).
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>
              An object that can be used to synchronize access to the WeakCollection.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.Count">
            <summary>
              The number of elements contained in the WeakCollection instance
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.Item(System.Int32)">
            <summary>Gets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
               Index is less than zero or index is equal to or greater than
               WeakCollection.Count.
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.IsReadOnly">
            <summary>Whether the List is write-protected</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator">
            <summary>
              An enumerator that unpacks the items returned by an enumerator of the
              weak reference collection into the actual item type on-the-fly.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.#ctor(System.Collections.Generic.IEnumerator{Nuclex.Support.WeakReference{`0}})">
            <summary>Initializes a new unpacking enumerator</summary>
            <param name="containedTypeEnumerator">
              Enumerator of the weak reference collection
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.Dispose">
            <summary>Immediately releases all resources used by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.MoveNext">
            <summary>Gets the current element in the collection.</summary>
            <returns>The current element in the collection.</returns>
            <exception cref="T:System.InvalidOperationException">
              The enumerator is positioned before the first element of the collection
              or after the last element.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.Reset">
            <summary>
              Sets the enumerator to its initial position, which is before the first element
              in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
              The collection was modified after the enumerator was created.
            </exception>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.containedTypeEnumerator">
            <summary>An enumerator from the wrapped collection</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.Current">
            <summary>
              The element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.System#Collections#IEnumerator#Current">
            <summary>The current element in the collection.</summary>
            <exception cref="T:System.InvalidOperationException">
              The enumerator is positioned before the first element of the collection
              or after the last element.
            </exception>
        </member>
        <member name="T:Nuclex.Support.Collections.Deque`1">
            <summary>A double-ended queue that allocates memory in blocks</summary>
            <typeparam name="TItem">Type of the items being stored in the queue</typeparam>
            <remarks>
              <para>
                The double-ended queue allows items to be appended to either side of the queue
                without a hefty toll on performance. Like its namesake in C++, it is implemented
                using multiple arrays.
              </para>
              <para>
                Therefore, it's not only good at coping with lists that are modified at their
                beginning, but also at handling huge data sets since enlarging the deque doesn't
                require items to be copied around and it still can be accessed by index.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Clear">
            <summary>Removes all items from the deque</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Remove(`0)">
            <summary>Removes the specified item from the deque</summary>
            <param name="item">Item that will be removed from the deque</param>
            <returns>True if the item was found and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.RemoveFirst">
            <summary>Removes the first item in the double-ended queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.RemoveLast">
            <summary>Removes the last item in the double-ended queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.RemoveAt(System.Int32)">
            <summary>Removes the item at the specified index</summary>
            <param name="index">Index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.removeFromLeft(System.Int32)">
            <summary>
              Removes an item from the left side of the queue by shifting all items that
              come before it to the right by one
            </summary>
            <param name="index">Index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.removeFromRight(System.Int32)">
            <summary>
              Removes an item from the right side of the queue by shifting all items that
              come after it to the left by one
            </summary>
            <param name="index">Index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.IndexOf(`0)">
            <summary>
              Determines the index of the first occurence of the specified item in the deque
            </summary>
            <param name="item">Item that will be located in the deque</param>
            <returns>The index of the item or -1 if it wasn't found</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.AddFirst(`0)">
            <summary>Inserts an item at the beginning of the double-ended queue</summary>
            <param name="item">Item that will be inserted into the queue</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.AddLast(`0)">
            <summary>Appends an item to the end of the double-ended queue</summary>
            <param name="item">Item that will be appended to the queue</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Insert(System.Int32,`0)">
            <summary>Inserts the item at the specified index</summary>
            <param name="index">Index the item will be inserted at</param>
            <param name="item">Item that will be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.shiftLeftAndInsert(System.Int32,`0)">
            <summary>
              Shifts all items before the insertion point to the left and inserts
              the item at the specified index
            </summary>
            <param name="index">Index the item will be inserted at</param>
            <param name="item">Item that will be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.shiftRightAndInsert(System.Int32,`0)">
            <summary>
              Shifts all items after the insertion point to the right and inserts
              the item at the specified index
            </summary>
            <param name="index">Index the item will be inserted at</param>
            <param name="item">Item that will be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Obtains a new enumerator for the contents of the deque</summary>
            <returns>The new enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the deque</summary>
            <param name="value">Item that will be added to the deque</param>
            <returns>The index at which the new item was added</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Contains(System.Object)">
            <summary>Checks whether the deque contains the specified item</summary>
            <param name="value">Item the deque will be scanned for</param>
            <returns>True if the deque contained the specified item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>Determines the index of the item in the deque</summary>
            <param name="value">Item whose index will be determined</param>
            <returns>The index of the specified item in the deque</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>Inserts an item into the deque at the specified location</summary>
            <param name="index">Index at which the item will be inserted</param>
            <param name="value">Item that will be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Remove(System.Object)">
            <summary>Removes the specified item from the deque</summary>
            <param name="value">Item that will be removed from the deque</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#Generic#ICollection{TItem}#Add(`0)">
            <summary>Adds an item into the deque</summary>
            <param name="item">Item that will be added to the deque</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the deque into an array</summary>
            <param name="array">Array the contents of the deque will be copied into</param>
            <param name="index">Index at which writing into the array will begin</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.#ctor">
            <summary>Initializes a new deque</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.#ctor(System.Int32)">
            <summary>Initializes a new deque using the specified block size</summary>
            <param name="blockSize">Size of the individual memory blocks used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Contains(`0)">
            <summary>Determines whether the deque contains the specified item</summary>
            <param name="item">Item the deque will be scanned for</param>
            <returns>True if the deque contains the item, false otherwise</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the deque into an array</summary>
            <param name="array">Array the contents of the deque will be copied into</param>
            <param name="arrayIndex">Array index the deque contents will begin at</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.GetEnumerator">
            <summary>Obtains a new enumerator for the contents of the deque</summary>
            <returns>The new enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.findIndex(System.Int32,System.Int32@,System.Int32@)">
            <summary>Calculates the block index and local sub index of an entry</summary>
            <param name="index">Index of the entry that will be located</param>
            <param name="blockIndex">Index of the block the entry is contained in</param>
            <param name="subIndex">Local sub index of the entry within the block</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.isCompatibleObject(System.Object)">
            <summary>
              Determines whether the provided object can be placed in the deque
            </summary>
            <param name="value">Value that will be checked for compatibility</param>
            <returns>True if the value can be placed in the deque</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.verifyCompatibleObject(System.Object)">
            <summary>Verifies that the provided object matches the deque's type</summary>
            <param name="value">Value that will be checked for compatibility</param>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.count">
            <summary>Number if items currently stored in the deque</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.blockSize">
            <summary>Size of a single deque block</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.blocks">
            <summary>Memory blocks being used to store the deque's data</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.firstBlockStartIndex">
            <summary>Starting index of data in the first block</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.lastBlockEndIndex">
            <summary>End index of data in the last block</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#IList#IsFixedSize">
            <summary>Whether the deque has a fixed size</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#IList#IsReadOnly">
            <summary>Whether the deque is read-only</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Item(System.Int32)">
            <summary>Accesses an item in the deque by its index</summary>
            <param name="index">Index of the item that will be accessed</param>
            <returns>The item at the specified index</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#Generic#ICollection{TItem}#IsReadOnly">
            <summary>Whether the collection is read-only</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the deque is thread-synchronized</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root of the instance</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Count">
            <summary>Number of items contained in the double ended queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Item(System.Int32)">
            <summary>Accesses an item by its index</summary>
            <param name="index">Index of the item that will be accessed</param>
            <returns>The item at the specified index</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.First">
            <summary>The first item in the double-ended queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Last">
            <summary>The last item in the double-ended queue</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.Deque`1.Enumerator">
            <summary>Enumerates over the items in a deque</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Enumerator.#ctor(Nuclex.Support.Collections.Deque{`0})">
            <summary>Initializes a new deque enumerator</summary>
            <param name="deque">Deque whose items will be enumerated</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Enumerator.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next item</summary>
            <returns>True if there was a next item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Enumerator.Reset">
            <summary>Resets the enumerator to its initial position</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.deque">
            <summary>Deque the enumerator belongs to</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.blockSize">
            <summary>Size of the blocks in the deque</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.lastBlock">
            <summary>Index of the last block in the deque</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.lastBlockEndIndex">
            <summary>End index of the items in the deque's last block</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.currentBlockIndex">
            <summary>Index of the block the enumerator currently is in</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.currentBlock">
            <summary>Reference to the block being enumerated</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.subIndex">
            <summary>Index in the current block</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Enumerator.Current">
            <summary>The item at the enumerator's current position</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>The item at the enumerator's current position</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.ReflectionCloner">
            <summary>Clones objects using reflection</summary>
            <remarks>
              <para>
                This type of cloning is a lot faster than cloning by serialization and
                incurs no set-up cost, but requires cloned types to provide a default
                constructor in order to work.
              </para>
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Cloning.ICloneFactory">
            <summary>Constructs new objects by cloning existing objects</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ICloneFactory.ShallowFieldClone``1(``0)">
            <summary>
              Creates a shallow clone of the specified object, reusing any referenced objects
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A shallow clone of the provided object</returns>
            <remarks>
              Field-based clones are guaranteed to be complete - there will be no missed
              members. This type of clone is also able to clone types that do not provide
              a default constructor.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Cloning.ICloneFactory.ShallowPropertyClone``1(``0)">
            <summary>
              Creates a shallow clone of the specified object, reusing any referenced objects
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A shallow clone of the provided object</returns>
            <remarks>
              <para>
                A property-based clone is useful if you're using dynamically generated proxies,
                such as when working with entities returned by an ORM like NHibernate.
                When not using a property-based clone, internal proxy fields would be cloned
                and might cause problems with the ORM.
              </para>
              <para>
                Property-based clones require a default constructor because there's no guarantee
                that all fields will are assignable through properties and starting with
                an uninitialized object is likely to end up with a broken clone.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Cloning.ICloneFactory.DeepFieldClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
            <remarks>
              Field-based clones are guaranteed to be complete - there will be no missed
              members. This type of clone is also able to clone types that do not provide
              a default constructor.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Cloning.ICloneFactory.DeepPropertyClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
            <remarks>
              <para>
                A property-based clone is useful if you're using dynamically generated proxies,
                such as when working with entities returned by an ORM like NHibernate.
                When not using a property-based clone, internal proxy fields would be cloned
                and might cause problems with the ORM.
              </para>
              <para>
                Property-based clones require a default constructor because there's no guarantee
                that all fields will are assignable through properties and starting with
                an uninitialized object is likely to end up with a broken clone.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.ShallowFieldClone``1(``0)">
            <summary>
              Creates a shallow clone of the specified object, reusing any referenced objects
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A shallow clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.ShallowPropertyClone``1(``0)">
            <summary>
              Creates a shallow clone of the specified object, reusing any referenced objects
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A shallow clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.DeepFieldClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.DeepPropertyClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.Nuclex#Support#Cloning#ICloneFactory#ShallowFieldClone``1(``0)">
            <summary>
              Creates a shallow clone of the specified object, reusing any referenced objects
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A shallow clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.Nuclex#Support#Cloning#ICloneFactory#ShallowPropertyClone``1(``0)">
            <summary>
              Creates a shallow clone of the specified object, reusing any referenced objects
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A shallow clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.Nuclex#Support#Cloning#ICloneFactory#DeepFieldClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.Nuclex#Support#Cloning#ICloneFactory#DeepPropertyClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.shallowCloneComplexFieldBased(System.Object)">
            <summary>Clones a complex type using field-based value transfer</summary>
            <param name="original">Original instance that will be cloned</param>
            <returns>A clone of the original instance</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.shallowCloneComplexPropertyBased(System.Object)">
            <summary>Clones a complex type using property-based value transfer</summary>
            <param name="original">Original instance that will be cloned</param>
            <returns>A clone of the original instance</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.shallowCloneArray(System.Object)">
            <summary>Clones an array using field-based value transfer</summary>
            <param name="original">Original array that will be cloned</param>
            <returns>A clone of the original array</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.deepCloneSingleFieldBased(System.Object)">
            <summary>Copies a single object using field-based value transfer</summary>
            <param name="original">Original object that will be cloned</param>
            <returns>A clone of the original object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.deepCloneComplexFieldBased(System.Object)">
            <summary>Clones a complex type using field-based value transfer</summary>
            <param name="original">Original instance that will be cloned</param>
            <returns>A clone of the original instance</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.deepCloneArrayFieldBased(System.Array,System.Type)">
            <summary>Clones an array using field-based value transfer</summary>
            <param name="original">Original array that will be cloned</param>
            <param name="elementType">Type of elements the original array contains</param>
            <returns>A clone of the original array</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.deepCloneSinglePropertyBased(System.Object)">
            <summary>Copies a single object using property-based value transfer</summary>
            <param name="original">Original object that will be cloned</param>
            <returns>A clone of the original object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.deepCloneComplexPropertyBased(System.Object)">
            <summary>Clones a complex type using property-based value transfer</summary>
            <param name="original">Original instance that will be cloned</param>
            <returns>A clone of the original instance</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ReflectionCloner.deepCloneArrayPropertyBased(System.Array,System.Type)">
            <summary>Clones an array using property-based value transfer</summary>
            <param name="original">Original array that will be cloned</param>
            <param name="elementType">Type of elements the original array contains</param>
            <returns>A clone of the original array</returns>
        </member>
        <member name="T:Nuclex.Support.StringSegment">
            <summary>Delimits a section of a string</summary>
            <remarks>
              <para>
                The design of this class pretty much mirrors that of the
                <see cref="T:System.ArraySegment" /> class found in the .NET framework, but is
                specialized to be used for strings, which can not be expressed as arrays but
                share a lot of the characteristics of an array.
              </para>
              <para>
                In certain situations, passing a StringSegment instead of the the actual
                section from a string is useful. For example, the caller might want to know
                from which index of the original string the substring was taken. Used internally
                in parsers, it can also prevent needless string copying and garbage generation.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringSegment.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Nuclex.Support.StringSegment"/> class that delimits
              all the elements in the specified string
            </summary>
            <param name="text">String that will be wrapped</param>
            <exception cref="T:System.ArgumentNullException">String is null</exception>
        </member>
        <member name="M:Nuclex.Support.StringSegment.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Nuclex.Support.StringSegment"/> class that delimits
              the specified range of the elements in the specified string
            </summary>
            <param name="text">The string containing the range of elements to delimit</param>
            <param name="offset">The zero-based index of the first element in the range</param>
            <param name="count">The number of elements in the range</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Offset or count is less than 0
            </exception>
            <exception cref="T:System.ArgumentException">
              Offset and count do not specify a valid range in array
            </exception>
            <exception cref="T:System.ArgumentNullException">String is null</exception>
        </member>
        <member name="M:Nuclex.Support.StringSegment.GetHashCode">
            <summary>Returns the hash code for the current instance</summary>
            <returns>A 32-bit signed integer hash code</returns>
        </member>
        <member name="M:Nuclex.Support.StringSegment.Equals(System.Object)">
            <summary>
              Determines whether the specified object is equal to the current instance
            </summary>
            <returns>
              True if the specified object is a <see cref="T:Nuclex.Support.StringSegment"/> structure and is
              equal to the current instance; otherwise, false
            </returns>
            <param name="other">The object to be compared with the current instance</param>
        </member>
        <member name="M:Nuclex.Support.StringSegment.Equals(Nuclex.Support.StringSegment)">
            <summary>
              Determines whether the specified <see cref="T:Nuclex.Support.StringSegment"/> structure is equal
              to the current instance
            </summary>
            <returns>
              True if the specified <see cref="T:Nuclex.Support.StringSegment"/> structure is equal to the
              current instance; otherwise, false
            </returns>
            <param name="other">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure to be compared with the current instance
            </param>
        </member>
        <member name="M:Nuclex.Support.StringSegment.op_Equality(Nuclex.Support.StringSegment,Nuclex.Support.StringSegment)">
            <summary>
              Indicates whether two <see cref="T:Nuclex.Support.StringSegment"/> structures are equal
            </summary>
            <returns>True if a is equal to b; otherwise, false</returns>
            <param name="left">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure on the left side of the
              equality operator
            </param>
            <param name="right">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure on the right side of the
              equality operator
            </param>
        </member>
        <member name="M:Nuclex.Support.StringSegment.op_Inequality(Nuclex.Support.StringSegment,Nuclex.Support.StringSegment)">
            <summary>
              Indicates whether two <see cref="T:Nuclex.Support.StringSegment"/> structures are unequal
            </summary>
            <returns>True if a is not equal to b; otherwise, false</returns>
            <param name="left">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure on the left side of the
              inequality operator
            </param>
            <param name="right">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure on the right side of the
              inequality operator
            </param>
        </member>
        <member name="M:Nuclex.Support.StringSegment.ToString">
            <summary>Returns a string representation of the string segment</summary>
            <returns>The string representation of the string segment</returns>
        </member>
        <member name="F:Nuclex.Support.StringSegment.text">
            <summary>String wrapped by the string segment</summary>
        </member>
        <member name="F:Nuclex.Support.StringSegment.offset">
            <summary>Offset in the original string the segment begins at</summary>
        </member>
        <member name="F:Nuclex.Support.StringSegment.count">
            <summary>Number of characters in the segment</summary>
        </member>
        <member name="P:Nuclex.Support.StringSegment.Text">
            <summary>
              Gets the original string containing the range of elements that the string
              segment delimits
            </summary>
            <returns>
              The original array that was passed to the constructor, and that contains the range
              delimited by the <see cref="T:Nuclex.Support.StringSegment"/>
            </returns>
        </member>
        <member name="P:Nuclex.Support.StringSegment.Offset">
            <summary>
              Gets the position of the first element in the range delimited by the array segment,
              relative to the start of the original array
            </summary>
            <returns>
              The position of the first element in the range delimited by the
              <see cref="T:Nuclex.Support.StringSegment"/>, relative to the start of the original array
            </returns>
        </member>
        <member name="P:Nuclex.Support.StringSegment.Count">
            <summary>
              Gets the number of elements in the range delimited by the array segment
            </summary>
            <returns>
              The number of elements in the range delimited by the <see cref="T:Nuclex.Support.StringSegment"/>
            </returns>
        </member>
        <member name="T:Nuclex.Support.StringBuilderHelperTest">
            <summary>
              Unit test for the helper class to .NET's string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendByte">
            <summary>
              Verifies that bytes are correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNullByte">
            <summary>
              Verifies that a byte with value 0 is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendPositiveInteger">
            <summary>
              Verifies that a positive integer is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNullInteger">
            <summary>
              Verifies that an integer with value 0 is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNegativeInteger">
            <summary>
              Verifies that a negative integer is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendPositiveLong">
            <summary>
              Verifies that a positive long integer is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNullLong">
            <summary>
              Verifies that a long integer with value 0 is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNegativeLong">
            <summary>
              Verifies that a negative long integer is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNegativeFloat">
            <summary>
              Verifies that negative floating point values are correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendPositiveFloat">
            <summary>
              Verifies that positive floating point values are correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendSmallFloat">
            <summary>
              Verifies that very small floating point values are correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendHugeFloat">
            <summary>
              Verifies that very large floating point values are correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendFloatLimitDecimalPlaces">
            <summary>Tests whether the number of decimal places can be restricted</summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendFloatWithoutDecimalPlaces">
            <summary>
              Verifies that a float with no decimal places is correctly appended
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendOutOfRangeFloat">
            <summary>
              Verifies the behavior of the helper with unsupported floating point values
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNegativeDouble">
            <summary>
              Verifies that negative double precision floating point values are
              correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendPositiveDouble">
            <summary>
              Verifies that positive double precision floating point values are
              correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendSmallDouble">
            <summary>
              Verifies that very small double precision floating point values are
              correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendHugeDouble">
            <summary>
              Verifies that very large double precision floating point values are
              correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendDoubleLimitDecimalPlaces">
            <summary>Tests whether the number of decimal places can be restricted</summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendDoubleWithoutDecimalPlaces">
            <summary>
              Verifies that a double with no decimal places is correctly appended
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendOutOfRangeDouble">
            <summary>
              Verifies the behavior of the helper with unsupported double precision
              floating point values
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestClear">
            <summary>
              Verifies that the contents of a string builder can be cleared
            </summary>
        </member>
        <member name="T:Nuclex.Support.PathHelperTest">
            <summary>Unit Test for the path helper class</summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeWindowsPathOfNonRelativePath">
            <summary>
              Tests whether the relative path creator keeps the absolute path if
              the location being passed is not relative to the base path.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeWindowsPathToParentFolder">
            <summary>
              Tests whether the relative path creator correctly builds the relative
              path to the parent folder of the base path for windows paths.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeWindowsPathToParentFolderTwoLevels">
            <summary>
              Tests whether the relative path creator correctly builds the relative path to
              the parent folder of the base path for windows paths with more than one level.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeUnixPathToParentFolder">
            <summary>
              Tests whether the relative path creator correctly builds the relative
              path to the parent folder of the base path for unix paths.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeUnixPathToParentFolderTwoLevels">
            <summary>
              Tests whether the relative path creator correctly builds the relative path to
              the parent folder of the base path for unix paths with more than one level.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeWindowsPathToNestedFolder">
            <summary>
              Tests whether the relative path creator correctly builds the relative
              path to a nested folder in the base path for windows paths.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeUnixPathToNestedFolder">
            <summary>
              Tests whether the relative path creator correctly builds the relative
              path to a nested folder in the base path for unix paths.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeWindowsPathToSiblingFolder">
            <summary>
              Tests whether the relative path creator correctly builds the relative
              path to another folder on the same level as base path for windows paths.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeUnixPathToSiblingFolder">
            <summary>
              Tests whether the relative path creator correctly builds the relative
              path to another folder on the same level as base path for unix paths.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.platformify(System.String)">
            <summary>
              Converts unix-style directory separators into the format used by the current platform
            </summary>
            <param name="path">Path to converts into the platform-dependent format</param>
            <returns>Platform-specific version of the provided unix-style path</returns>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLineTest">
            <summary>Ensures that the command line parser is working properly</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestDefaultConstructor">
            <summary>Verifies that the default constructor is working</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseAmbiguousNameResolution">
            <summary>
              Validates that the parser can handle an argument initiator with an
              assignment that is missing a name
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseShortArgumentInitiatorOnly">
            <summary>
              Verifies that a lone short argument initiator without anything behind
              can be parsed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseLongArgumentInitiatorOnly">
            <summary>
              Verifies that a lone long argument initiator without anything behind
              can be parsed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseArgumentInitiatorAtEnd">
            <summary>
              Validates that the parser can handle multiple lone argument initators without
              a following argument
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseQuotedValue">
            <summary>Validates that quoted arguments can be parsed</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseNull">
            <summary>Validates that null can be parsed</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseSingleNakedValue">
            <summary>Validates that a single argument without quotes can be parsed</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseQuotedArgumentWithoutClosingQuote">
            <summary>
              Validates that the parser can handle a quoted argument that's missing
              the closing quote
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseQuotedValueWithoutClosingQuote">
            <summary>
              Validates that the parser correctly handles a quoted value assignment that's
              missing the closing quote
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseSpacesOnly">
            <summary>
              Validates that the parser can handle an command line consisting of only spaces
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseQuotedOption">
            <summary>
              Validates that the parser can handle a quoted option
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseMultipleLoneArgumentInitiators">
            <summary>
              Validates that the parser can handle multiple lone argument initators without
              a following argument
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseOptionWithEmbeddedInitiator">
            <summary>
              Verifies that the parser correctly handles options with embedded option initiators
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseOptionAndValueWithoutSpaces">
            <summary>
              Validates that arguments and values without spaces inbetween can be parsed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseOptionWithModifierAtEnd">
            <summary>
              Validates that options with modifiers at the end of the command line
              are parsed successfully
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseOptionWithAssignment">
            <summary>
              Validates that options with values assigned to them are parsed successfully
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseOptionAtEndOfString">
            <summary>
              Validates that options with an empty value at the end of the command line
              string are parsed successfully
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestWindowsOptionInitiator">
            <summary>
              Verifies that the parser can recognize windows command line options if
              configured to windows mode
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestNonWindowsOptionValues">
            <summary>
              Verifies that the parser ignores windows command line options if
              configured to non-windows mode
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.HasArgumentWorksForWindowsStyleArguments">
            <summary>
              Tests whether the existence of named arguments can be checked
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.HasArgumentWorksForUnixStyleArguments">
            <summary>
              Tests whether the existence of named arguments can be checked
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestCommandLineFormatting">
            <summary>
              Tests whether a command line can be built with the command line class
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestNullArgumentFormatting">
            <summary>
              Tests whether a command line can be built that contains empty arguments
            </summary>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest">
            <summary>Unit test for the command line option class</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestNameExtraction">
            <summary>
              Verifies that the name of a command line argument without a value can
              be extracted
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestNameExtractionFromSubstring">
            <summary>
              Verifies that the name of a command line argument without a value can be
              extracted when the argument is contained in a substring of a larger string
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestValueExtraction">
            <summary>
              Varifies that the name and value of a command line argument can be extracted
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestValueExtractionFromSubstring">
            <summary>
              Varifies that the name and value of a command line argument can be extracted
              when the argument is contained in a substring of a larger string
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestQuotedValueExtraction">
            <summary>
              Varifies that the name and value of a command line argument can be extracted
              when the option is assigned a quoted value
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestValuelessAssociatorRetrieval">
            <summary>
              Varifies that the associator of a command line argument with an open ended
              value assignment can be retrieved
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestValuelessAssociatorRetrievalFromSubstring">
            <summary>
              Varifies that the associator of a command line option with an open ended value
              assignment can be retrieved when the option is contained in a substring of
              a larger string
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestNamelessValueRetrieval">
            <summary>
              Varifies that a command line argument without an option name can be retrieved
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestNamelessValueRetrievalFromSubstring">
            <summary>
              Varifies that a command line argument without an option name can be retrieved
              that is contained in a substring of larger string
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlySet`1">
            <summary>Wraps a set and prevents it from being modified</summary>
            <typeparam name="TItem">Type of items to manage in the set</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.#ctor(System.Collections.Generic.ISet{`0})">
            <summary>
              Initializes a new observable set forwarding operations to the specified set
            </summary>
            <param name="set">Set operations will be forwarded to</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Determines whether the current set is a proper (strict) subset of a collection
            </summary>
            <param name="other">Collection against which the set will be tested</param>
            <returns>True if the set is a proper subset of the specified collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Determines whether the current set is a proper (strict) superset of a collection
            </summary>
            <param name="other">Collection against which the set will be tested</param>
            <returns>True if the set is a proper superset of the specified collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a subset of a collection</summary>
            <param name="other">Collection against which the set will be tested</param>
            <returns>True if the set is a subset of the specified collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a superset of a collection</summary>
            <param name="other">Collection against which the set will be tested</param>
            <returns>True if the set is a superset of the specified collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Determines if the set shares at least one common element with the collection
            </summary>
            <param name="other">Collection the set will be tested against</param>
            <returns>
              True if the set shares at least one common element with the collection
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Determines whether the set contains the same elements as the specified collection
            </summary>
            <param name="other">Collection the set will be tested against</param>
            <returns>True if the set contains the same elements as the collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.Contains(`0)">
            <summary>Determines whether the set contains the specified item</summary>
            <param name="item">Item the set will be tested for</param>
            <returns>True if the set contains the specified item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the set into an array</summary>
            <param name="array">Array the set's contents will be copied to</param>
            <param name="arrayIndex">
              Index in the array the first copied element will be written to
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.GetEnumerator">
            <summary>Creates an enumerator for the set's contents</summary>
            <returns>A new enumerator for the sets contents</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Creates an enumerator for the set's contents</summary>
            <returns>A new enumerator for the sets contents</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.System#Collections#Generic#ISet{TItem}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Modifies the current set so that it contains only elements that are present either
              in the current set or in the specified collection, but not both
            </summary>
            <param name="other">Collection the set will be excepted with</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.System#Collections#Generic#ISet{TItem}#UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Modifies the current set so that it contains all elements that are present in both
              the current set and in the specified collection
            </summary>
            <param name="other">Collection an union will be built with</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.Clear">
            <summary>Removes all items from the set</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.System#Collections#Generic#ICollection{TItem}#Remove(`0)">
            <summary>Removes an item from the set</summary>
            <param name="item">Item that will be removed from the set</param>
            <returns>
              True if the item was contained in the set and is now removed
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.System#Collections#Generic#ISet{TItem}#Add(`0)">
            <summary>Adds an item to the set</summary>
            <param name="item">Item that will be added to the set</param>
            <returns>
              True if the element was added, false if it was already contained in the set
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.System#Collections#Generic#ISet{TItem}#ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes all elements that are contained in the collection</summary>
            <param name="other">Collection whose elements will be removed from this set</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.System#Collections#Generic#ISet{TItem}#IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Only keeps those elements in this set that are contained in the collection
            </summary>
            <param name="other">Other set this set will be filtered by</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySet`1.System#Collections#Generic#ICollection{TItem}#Add(`0)">
            <summary>Adds an item to the set</summary>
            <param name="item">Item that will be added to the set</param>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlySet`1.set">
            <summary>The set being wrapped</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlySet`1.Count">
            <summary>Counts the number of items contained in the set</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlySet`1.IsReadOnly">
            <summary>Determines whether the set is readonly</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyCollection`1">
            <summary>Wraps a Collection and prevents users from modifying it</summary>
            <typeparam name="TItem">Type of items to manage in the Collection</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>Initializes a new read-only Collection wrapper</summary>
            <param name="collection">Collection that will be wrapped</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.Contains(`0)">
            <summary>Determines whether the List contains the specified item</summary>
            <param name="item">Item that will be checked for</param>
            <returns>True if the specified item is contained in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the List into an array</summary>
            <param name="array">Array the List will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.GetEnumerator">
            <summary>Returns a new enumerator over the contents of the List</summary>
            <returns>The new List contents enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#Generic#ICollection{TItem}#Add(`0)">
            <summary>Adds an item to the end of the List</summary>
            <param name="item">Item that will be added to the List</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#Generic#ICollection{TItem}#Clear">
            <summary>Removes all items from the List</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#Generic#ICollection{TItem}#Remove(`0)">
            <summary>Removes the specified item from the List</summary>
            <param name="item">Item that will be removed from the List</param>
            <returns>True of the specified item was found in the List and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new enumerator over the contents of the List</summary>
            <returns>The new List contents enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the List into an array</summary>
            <param name="array">Array the List will be copied into</param>
            <param name="index">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyCollection`1.typedCollection">
            <summary>The wrapped Collection under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyCollection`1.objectCollection">
            <summary>The wrapped Collection under its object interface</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyCollection`1.Count">
            <summary>The number of items current contained in the List</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyCollection`1.IsReadOnly">
            <summary>Whether the List is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the List is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the List locks</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityQueueTest">
            <summary>Unit Test for the priority queue class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueueTest.TestCount">
            <summary>Tests to ensure the count property is properly updated</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueueTest.TestOrdering">
            <summary>Tests to ensure that the priority collection actually sorts items</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueueTest.TestPeekEmptyQueue">
            <summary>
              Verifies that an exception is thrown when Peek() is called on an empty queue
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueueTest.TestDequeueEmptyQueue">
            <summary>
              Verifies that an exception is thrown when Dequeue() is called on an empty queue
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueueTest.TestLargeQueue">
            <summary>
              Verifies that the priority queue can handle large amounts of data
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityQueueTest.FloatComparer">
            <summary>Comparer for two floating point values</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueueTest.FloatComparer.Default">
            <summary>The default instance of this comparer</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueueTest.FloatComparer.Compare(System.Single,System.Single)">
            <summary>Compares two floating points against each other</summary>
            <param name="left">First float to compare</param>
            <param name="right">Second float to compare</param>
            <returns>The relationship of the two floats to each other</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.PoolTest">
            <summary>Unit tests for the Pool class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.NewInstancesCanBeObtained">
            <summary>
              Verifies that the pool can return newly constructed objects
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.UsingDefaultInstanceCreatorRequiresDefaultConstructor">
            <summary>
              Verifies that an exception is thrown if the pool's default instance creator is used
              on a type that doesn't have a default constructor
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.InstancesCanBeRedeemed">
            <summary>
              Tests whether the pool can redeem objects that are no longer used
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.RedeemedItemsWillBeRecycled">
            <summary>
              Tests whether the Recycle() method is called at the appropriate time
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.PoolCapacityCanBeAdjusted">
            <summary>Verifies that the pool's Capacity is applied correctly</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PoolTest.TestClass">
            <summary>Used to test the pool</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.TestClass.Recycle">
            <summary>Returns the object to its initial state</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PoolTest.TestClass.Recycled">
            <summary>Whether the instance has been recycled</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PoolTest.NoDefaultConstructor">
            <summary>Used to test the pool</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.NoDefaultConstructor.#ctor">
            <summary>Private constructor so no instances can be created</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ItemReplaceEventArgs`1">
            <summary>
              Argument container used by collections to notify about replaced items
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ItemReplaceEventArgs`1.#ctor(`0,`0)">
            <summary>Initializes a new event arguments supplier</summary>
            <param name="oldItem">Item that has been replaced by another item</param>
            <param name="newItem">Replacement item that is now part of the collection</param>
        </member>
        <member name="F:Nuclex.Support.Collections.ItemReplaceEventArgs`1.oldItem">
            <summary>Item that was removed from the collection</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ItemReplaceEventArgs`1.newItem">
            <summary>Item that was added to the collection</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ItemReplaceEventArgs`1.OldItem">
            <summary>Item that has been replaced by another item</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ItemReplaceEventArgs`1.NewItem">
            <summary>Replacement item that is now part of the collection</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.ExpressionTreeCloner">
            <summary>
              Cloning factory which uses expression trees to improve performance when cloning
              is a high-frequency action.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.#cctor">
            <summary>Initializes the static members of the expression tree cloner</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.DeepFieldClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.DeepPropertyClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.ShallowFieldClone``1(``0)">
            <summary>
              Creates a shallow clone of the specified object, reusing any referenced objects
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A shallow clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.ShallowPropertyClone``1(``0)">
            <summary>
              Creates a shallow clone of the specified object, reusing any referenced objects
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A shallow clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.Nuclex#Support#Cloning#ICloneFactory#ShallowFieldClone``1(``0)">
            <summary>
              Creates a shallow clone of the specified object, reusing any referenced objects
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A shallow clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.Nuclex#Support#Cloning#ICloneFactory#ShallowPropertyClone``1(``0)">
            <summary>
              Creates a shallow clone of the specified object, reusing any referenced objects
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A shallow clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.Nuclex#Support#Cloning#ICloneFactory#DeepFieldClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.Nuclex#Support#Cloning#ICloneFactory#DeepPropertyClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.getOrCreateShallowFieldBasedCloner(System.Type)">
            <summary>
              Retrieves the existing clone method for the specified type or compiles one if
              none exists for the type yet
            </summary>
            <param name="clonedType">Type for which a clone method will be retrieved</param>
            <returns>The clone method for the specified type</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.getOrCreateDeepFieldBasedCloner(System.Type)">
            <summary>
              Retrieves the existing clone method for the specified type or compiles one if
              none exists for the type yet
            </summary>
            <param name="clonedType">Type for which a clone method will be retrieved</param>
            <returns>The clone method for the specified type</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.getOrCreateShallowPropertyBasedCloner(System.Type)">
            <summary>
              Retrieves the existing clone method for the specified type or compiles one if
              none exists for the type yet
            </summary>
            <param name="clonedType">Type for which a clone method will be retrieved</param>
            <returns>The clone method for the specified type</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.getOrCreateDeepPropertyBasedCloner(System.Type)">
            <summary>
              Retrieves the existing clone method for the specified type or compiles one if
              none exists for the type yet
            </summary>
            <param name="clonedType">Type for which a clone method will be retrieved</param>
            <returns>The clone method for the specified type</returns>
        </member>
        <member name="F:Nuclex.Support.Cloning.ExpressionTreeCloner.shallowFieldBasedCloners">
            <summary>Compiled cloners that perform shallow clone operations</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.ExpressionTreeCloner.deepFieldBasedCloners">
            <summary>Compiled cloners that perform deep clone operations</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.ExpressionTreeCloner.shallowPropertyBasedCloners">
            <summary>Compiled cloners that perform shallow clone operations</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.ExpressionTreeCloner.deepPropertyBasedCloners">
            <summary>Compiled cloners that perform deep clone operations</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.createDeepFieldBasedCloner(System.Type)">
            <summary>Compiles a method that creates a deep clone of an object</summary>
            <param name="clonedType">Type for which a clone method will be created</param>
            <returns>A method that clones an object of the provided type</returns>
            <remarks>
              <para>
                The 'null' check is supposed to take place before running the cloner. This
                avoids having redundant 'null' checks on nested types - first before calling
                GetType() on the field to be cloned and second when runner the matching
                cloner for the field.
              </para>
              <para>
                This design also enables the cloning of nested value types (which can never
                be null) without any null check whatsoever.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.createShallowFieldBasedCloner(System.Type)">
            <summary>Compiles a method that creates a shallow clone of an object</summary>
            <param name="clonedType">Type for which a clone method will be created</param>
            <returns>A method that clones an object of the provided type</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.generateFieldBasedPrimitiveArrayTransferExpressions(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.ICollection{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.ICollection{System.Linq.Expressions.Expression})">
            <summary>
              Generates state transfer expressions to copy an array of primitive types
            </summary>
            <param name="clonedType">Type of array that will be cloned</param>
            <param name="original">Variable expression for the original array</param>
            <param name="variables">Receives variables used by the transfer expressions</param>
            <param name="transferExpressions">Receives the generated transfer expressions</param>
            <returns>The variable holding the cloned array</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.generateFieldBasedComplexArrayTransferExpressions(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.ICollection{System.Linq.Expressions.Expression})">
            <summary>
              Generates state transfer expressions to copy an array of complex types
            </summary>
            <param name="clonedType">Type of array that will be cloned</param>
            <param name="original">Variable expression for the original array</param>
            <param name="variables">Receives variables used by the transfer expressions</param>
            <param name="transferExpressions">Receives the generated transfer expressions</param>
            <returns>The variable holding the cloned array</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.generateFieldBasedComplexTypeTransferExpressions(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.ICollection{System.Linq.Expressions.Expression})">
            <summary>Generates state transfer expressions to copy a complex type</summary>
            <param name="clonedType">Complex type that will be cloned</param>
            <param name="original">Variable expression for the original instance</param>
            <param name="clone">Variable expression for the cloned instance</param>
            <param name="variables">Receives variables used by the transfer expressions</param>
            <param name="transferExpressions">Receives the generated transfer expressions</param>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.generateFieldBasedReferenceTypeTransferExpressions(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.ICollection{System.Linq.Expressions.Expression},System.Reflection.FieldInfo,System.Type)">
            <summary>
              Generates the expressions to transfer a reference type (array or class)
            </summary>
            <param name="original">Original value that will be cloned</param>
            <param name="clone">Variable that will receive the cloned value</param>
            <param name="transferExpressions">
              Receives the expression generated to transfer the values
            </param>
            <param name="fieldInfo">Reflection informations about the field being cloned</param>
            <param name="fieldType">Type of the field being cloned</param>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.assignInitOnlyField``1(``0@,System.Reflection.FieldInfo,System.Object)">
            <summary>Assigns the value of an .initonly field</summary>
            <typeparam name="TValueType">Type of structure that contains the field</typeparam>
            <param name="instance">
              Reference to the structure on which the field will be assigned
            </param>
            <param name="fieldInfo">Field that will be assigned</param>
            <param name="value">Value that will be assigned to the field</param>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.createDeepPropertyBasedCloner(System.Type)">
            <summary>Compiles a method that creates a deep clone of an object</summary>
            <param name="clonedType">Type for which a clone method will be created</param>
            <returns>A method that clones an object of the provided type</returns>
            <remarks>
              <para>
                The 'null' check is supposed to take place before running the cloner. This
                avoids having redundant 'null' checks on nested types - first before calling
                GetType() on the property to be cloned and second when runner the matching
                cloner for the property.
              </para>
              <para>
                This design also enables the cloning of nested value types (which can never
                be null) without any null check whatsoever.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.createShallowPropertyBasedCloner(System.Type)">
            <summary>Compiles a method that creates a deep clone of an object</summary>
            <param name="clonedType">Type for which a clone method will be created</param>
            <returns>A method that clones an object of the provided type</returns>
            <remarks>
              <para>
                The 'null' check is supposed to take place before running the cloner. This
                avoids having redundant 'null' checks on nested types - first before calling
                GetType() on the property to be cloned and second when runner the matching
                cloner for the property.
              </para>
              <para>
                This design also enables the cloning of nested value types (which can never
                be null) without any null check whatsoever.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.generateShallowPropertyBasedComplexCloneExpressions(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Collections.Generic.ICollection{System.Linq.Expressions.Expression},System.Collections.Generic.ICollection{System.Linq.Expressions.ParameterExpression})">
            <summary>
              Generates expressions to transfer the properties of a complex value type
            </summary>
            <param name="clonedType">Complex value type that will be cloned</param>
            <param name="original">Original instance whose properties will be cloned</param>
            <param name="clone">Target instance into which the properties will be copied</param>
            <param name="transferExpressions">Receives the value transfer expressions</param>
            <param name="variables">Receives temporary variables used during the clone</param>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.generatePropertyBasedPrimitiveArrayTransferExpressions(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.ICollection{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.ICollection{System.Linq.Expressions.Expression})">
            <summary>
              Generates state transfer expressions to copy an array of primitive types
            </summary>
            <param name="clonedType">Type of array that will be cloned</param>
            <param name="original">Variable expression for the original array</param>
            <param name="variables">Receives variables used by the transfer expressions</param>
            <param name="transferExpressions">Receives the generated transfer expressions</param>
            <returns>The variable holding the cloned array</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.generatePropertyBasedComplexArrayTransferExpressions(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.ICollection{System.Linq.Expressions.Expression})">
            <summary>
              Generates state transfer expressions to copy an array of complex types
            </summary>
            <param name="clonedType">Type of array that will be cloned</param>
            <param name="original">Variable expression for the original array</param>
            <param name="variables">Receives variables used by the transfer expressions</param>
            <param name="transferExpressions">Receives the generated transfer expressions</param>
            <returns>The variable holding the cloned array</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.generatePropertyBasedComplexTypeTransferExpressions(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.ICollection{System.Linq.Expressions.Expression})">
            <summary>Generates state transfer expressions to copy a complex type</summary>
            <param name="clonedType">Complex type that will be cloned</param>
            <param name="original">Variable expression for the original instance</param>
            <param name="clone">Variable expression for the cloned instance</param>
            <param name="variables">Receives variables used by the transfer expressions</param>
            <param name="transferExpressions">Receives the generated transfer expressions</param>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeCloner.generatePropertyBasedReferenceTypeTransferExpressions(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.ICollection{System.Linq.Expressions.Expression},System.Collections.Generic.ICollection{System.Linq.Expressions.ParameterExpression},System.Reflection.PropertyInfo,System.Type)">
            <summary>
              Generates the expressions to transfer a reference type (array or class)
            </summary>
            <param name="original">Original value that will be cloned</param>
            <param name="clone">Variable that will receive the cloned value</param>
            <param name="transferExpressions">
              Receives the expression generated to transfer the values
            </param>
            <param name="variables">Receives variables used by the transfer expressions</param>
            <param name="propertyInfo">Reflection informations about the property being cloned</param>
            <param name="propertyType">Type of the property being cloned</param>
        </member>
        <member name="T:Nuclex.Support.ObservableTest">
            <summary>Unit tests for observable class</summary>
        </member>
        <member name="M:Nuclex.Support.ObservableTest.Setup">
            <summary>Called before each unit test is run</summary>
        </member>
        <member name="M:Nuclex.Support.ObservableTest.PropertyNameCanBeSpecifiedManually">
            <summary>
              Verifies that the name of the changed property can be specified manually
              when triggering the PropertyChanged event
            </summary>
        </member>
        <member name="M:Nuclex.Support.ObservableTest.PropertyNameCanBeDeducedFromLambdaExpression">
            <summary>
              Verifies that the observable is capable of deducing the name of the property
              from a lambda expression
            </summary>
        </member>
        <member name="M:Nuclex.Support.ObservableTest.WildcardChangeNotificationsCanBeSent">
            <summary>
              Verifies that change notifications for all properties of a type can
              be generated
            </summary>
        </member>
        <member name="F:Nuclex.Support.ObservableTest.testObservable">
            <summary>Observable object being tested</summary>
        </member>
        <member name="F:Nuclex.Support.ObservableTest.subscriber">
            <summary>Subscriber to the observable object being tested</summary>
        </member>
        <member name="T:Nuclex.Support.ObservableTest.TestObservable">
            <summary>Example class on which unit test generates change notifications</summary>
        </member>
        <member name="T:Nuclex.Support.Observable">
            <summary>Base class for objects that support property change notifications</summary>
        </member>
        <member name="M:Nuclex.Support.Observable.OnPropertyChanged``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>Triggers the PropertyChanged event for the specified property</summary>
            <param name="property">
              Lambda expression for the property that will be reported to have changed
            </param>
            <remarks>
              <para>
                This notification should be fired post-change, i.e. when the property has
                already changed its value.
              </para>
              <example>
                <code>
                  public int Limit {
                    get { return this.limit; }
                    set {
                      if(value != this.limit) {
                        this.limit = value;
                        OnPropertyChanged(() => Limit);
                      }
                    }
                  }
                </code>
              </example>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Observable.OnPropertyChanged(System.String)">
            <summary>Triggers the PropertyChanged event for the specified property</summary>
            <param name="propertyName">Name of the property that has changed its value</param>
            <remarks>
              <para>
                This notification should be fired post-change, i.e. when the property has
                already changed its value. If possible, use the other overload of this
                method to ensure the property name will be updated during F2 refactoring.
              </para>
              <example>
                <code>
                  public int Limit {
                    get { return this.limit; }
                    set {
                      if(value != this.limit) {
                        this.limit = value;
                        OnPropertyChanged("Limit"); // Note: prefer lambda exp whenever possible
                      }
                    }
                  }
                </code>
              </example>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Observable.enforceChangedPropertyExists(System.String)">
            <summary>Ensures that a property with the specified name exists in the type</summary>
            <param name="propertyName">Property name that will be checked</param>
        </member>
        <member name="E:Nuclex.Support.Observable.PropertyChanged">
            <summary>Raised when a property of the instance has changed its value</summary>
        </member>
        <member name="M:Nuclex.Support.ObservableTest.TestObservable.FirePropertyChanged(System.String)">
            <summary>Triggers the property changed event for the specified property</summary>
            <param name="propertyName">
              Name of the property that will be reported as changed
            </param>
        </member>
        <member name="M:Nuclex.Support.ObservableTest.TestObservable.FireSomePropertyChanged">
            <summary>Fires the property changed event for the 'SomePropety' property</summary>
        </member>
        <member name="P:Nuclex.Support.ObservableTest.TestObservable.SomeProperty">
            <summary>Example property that will be reported to have changed</summary>
        </member>
        <member name="T:Nuclex.Support.ObservableTest.MockedSubscriber">
            <summary>Mocked change notification subscriber</summary>
        </member>
        <member name="M:Nuclex.Support.ObservableTest.MockedSubscriber.PropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Called when the value of a property has changed</summary>
            <param name="sender">Object of which a property has changed</param>
            <param name="arguments">Contains the name of the changed property</param>
        </member>
        <member name="M:Nuclex.Support.ObservableTest.MockedSubscriber.WasNotifiedOfChangeTo(System.String)">
            <summary>
              Checks whether a change notification for the specified property was received
            </summary>
            <param name="propertyName">Name of the property that will be checked for</param>
            <returns>
              True if a change notification for the specified property was received
            </returns>
        </member>
        <member name="F:Nuclex.Support.ObservableTest.MockedSubscriber.wasNotified">
            <summary>Whether a change notification was received</summary>
        </member>
        <member name="F:Nuclex.Support.ObservableTest.MockedSubscriber.changedPropertyName">
            <summary>Name of the property for which a change notification was received</summary>
        </member>
        <member name="P:Nuclex.Support.ObservableTest.MockedSubscriber.WasNotified">
            <summary>Whether the subscriber was notified of a property change</summary>
        </member>
        <member name="T:Nuclex.Support.PropertyChangedEventArgsHelperTest">
            <summary>Unit tests for the property change event argument helper</summary>
        </member>
        <member name="M:Nuclex.Support.PropertyChangedEventArgsHelperTest.MatchingPropertyChangeNotificationIsRecognized">
            <summary>
              Verifies that a property change notification matching the property
              passed to the AreAffecting() method is recognized
            </summary>
        </member>
        <member name="M:Nuclex.Support.PropertyChangedEventArgsHelperTest.MismatchingPropertyIsReportedAsUnaffected">
            <summary>
              Ensures that a mismatching property change notification will
              not report the property as being affected.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PropertyChangedEventArgsHelperTest.SpecificPropertyIsAffectedByNullWildcard">
            <summary>
              Verifies that any specific property is reported as being affected
              when the property change notification is a null wildcard 
            </summary>
        </member>
        <member name="M:Nuclex.Support.PropertyChangedEventArgsHelperTest.SpecificPropertyIsAffectedByEmptyWildcard">
            <summary>
              Verifies that any specific property is reported as being affected
              when the property change notification is an empty wildcard 
            </summary>
        </member>
        <member name="M:Nuclex.Support.PropertyChangedEventArgsHelperTest.NullWildcardIsRecognized">
            <summary>
              Tests whether the helper can recognize a wildcard property change
              notification using null as the wildcard.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PropertyChangedEventArgsHelperTest.EmptyWildcardIsRecognized">
            <summary>
              Tests whether the helper can recognize a wildcard property change
              notification using an empty string as the wildcard.
            </summary>
        </member>
        <member name="P:Nuclex.Support.PropertyChangedEventArgsHelperTest.ViewModel">
            <summary>Helper used to construct lambda expressions</summary>
        </member>
        <member name="T:Nuclex.Support.PropertyChangedEventArgsHelperTest.TestViewModel">
            <summary>Example class on which unit test generates change notifications</summary>
        </member>
        <member name="P:Nuclex.Support.PropertyChangedEventArgsHelperTest.TestViewModel.SomeProperty">
            <summary>Example property that will be reported to have changed</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReverseComparerTest">
            <summary>Unit Test for the ReverseComparer helper class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparerTest.TestDefaultConstructor">
            <summary>
              Tests whether the default constructor of the reverse comparer works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparerTest.TestFullConstructor">
            <summary>
              Tests whether the full constructor of the reverse comparer works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparerTest.TestReversedDefaultComparer">
            <summary>
              Tests whether the full constructor of the reverse comparer works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparerTest.TestReversedCustomComparer">
            <summary>
              Tests whether the full constructor of the reverse comparer works
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReverseComparerTest.FortyTwoComparer">
            <summary>Special comparer in which 42 is larger than everything</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparerTest.FortyTwoComparer.Compare(System.Int32,System.Int32)">
            <summary>Compares the left value to the right value</summary>
            <param name="left">Value on the left side</param>
            <param name="right">Value on the right side</param>
            <returns>The relationship of the two values</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityQueue`1">
            <summary>Queue that dequeues items in order of their priority</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.#ctor">
            <summary>
              Initializes a new priority queue using IComparable for comparing items
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>Initializes a new priority queue</summary>
            <param name="comparer">Comparer to use for ordering the items</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Peek">
            <summary>Returns the topmost item in the queue without dequeueing it</summary>
            <returns>The topmost item in the queue</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Dequeue">
            <summary>Takes the item with the highest priority off from the queue</summary>
            <returns>The item with the highest priority in the list</returns>
            <exception cref="T:System.InvalidOperationException">When the queue is empty</exception>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enqueue(`0)">
            <summary>Puts an item into the priority queue</summary>
            <param name="item">Item to be queued</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Clear">
            <summary>Removes all items from the priority queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the priority queue into an array</summary>
            <param name="array">Array to copy the priority queue into</param>
            <param name="index">Starting index for the destination array</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.GetEnumerator">
            <summary>Returns a typesafe enumerator for the priority queue</summary>
            <returns>A new enumerator for the priority queue</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.bubbleUp(System.Int32,`0)">
            <summary>Moves an item upwards in the heap tree</summary>
            <param name="index">Index of the item to be moved</param>
            <param name="item">Item to be moved</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.trickleDown(System.Int32,`0)">
            <summary>Move the item downwards in the heap tree</summary>
            <param name="index">Index of the item to be moved</param>
            <param name="item">Item to be moved</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.getLeftChild(System.Int32)">
            <summary>Obtains the left child item in the heap tree</summary>
            <param name="index">Index of the item whose left child to return</param>
            <returns>The left child item of the provided parent item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.getParent(System.Int32)">
            <summary>Calculates the parent entry of the item on the heap</summary>
            <param name="index">Index of the item whose parent to calculate</param>
            <returns>The index of the parent to the specified item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.growHeap">
            <summary>Increases the size of the priority collection's heap</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator for the priority queue</summary>
            <returns>A new enumerator for the priority queue</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.comparer">
            <summary>Comparer used to order the items in the priority queue</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.count">
            <summary>Total number of items in the priority queue</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.capacity">
            <summary>Available space in the priority queue</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.heap">
            <summary>Tree containing the items in the priority queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.Count">
            <summary>Total number of items in the priority queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.SyncRoot">
            <summary>
              Obtains an object that can be used to synchronize accesses to the priority queue
              from different threads
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.IsSynchronized">
            <summary>Whether operations performed on this priority queue are thread safe</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityQueue`1.Enumerator">
            <summary>Enumerates all items contained in a priority queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.#ctor(Nuclex.Support.Collections.PriorityQueue{`0})">
            <summary>Initializes a new priority queue enumerator</summary>
            <param name="priorityQueue">Priority queue to be enumerated</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.Reset">
            <summary>Resets the enumerator to its initial state</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.MoveNext">
            <summary>Moves to the next item in the priority queue</summary>
            <returns>True if a next item was found, false if the end has been reached</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.Dispose">
            <summary>Releases all resources used by the enumerator</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.index">
            <summary>Index of the current item in the priority queue</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.priorityQueue">
            <summary>The priority queue whose items this instance enumerates</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.System#Collections#Generic#IEnumerator{TItem}#Current">
            <summary>The current item being enumerated</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>The current item being enumerated</summary>
        </member>
        <member name="T:Nuclex.Support.FloatHelperTest">
            <summary>Unit Test for the FloatHelper class</summary>
        </member>
        <member name="M:Nuclex.Support.FloatHelperTest.TestFloatComparison">
            <summary>Tests the floating point value comparison helper</summary>
        </member>
        <member name="M:Nuclex.Support.FloatHelperTest.TestDoubleComparison">
            <summary>Tests the double precision floating point value comparison helper</summary>
        </member>
        <member name="M:Nuclex.Support.FloatHelperTest.TestIntegerReinterpretation">
            <summary>Tests the integer reinterpretation functions</summary>
        </member>
        <member name="M:Nuclex.Support.FloatHelperTest.TestLongReinterpretation">
            <summary>Tests the long reinterpretation functions</summary>
        </member>
        <member name="M:Nuclex.Support.FloatHelperTest.TestFloatReinterpretation">
            <summary>Tests the floating point reinterpretation functions</summary>
        </member>
        <member name="M:Nuclex.Support.FloatHelperTest.TestDoubleReinterpretation">
            <summary>
              Tests the double prevision floating point reinterpretation functions
            </summary>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPoolTest">
            <summary>Unit Test for the CPU core-affine thread pool</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestQueueUserWorkItem">
            <summary>Tests whether the QueueUserWorkItem() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestQueueUserWorkItemWithState">
            <summary>
              Verifies that the QueueUserWorkItem() method is passing the state parameter
              on to the callback
            </summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestExceptionFromUserWorkItem">
            <summary>
              Tests whether the thread pool can handle an exception from a user work item
            </summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestMaxThreadsProperty">
            <summary>
              Verifies that the affine thread pool's maximum thread count equals
              the number of logical processors in the system
            </summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.CanGetProcessThreadForManagedThread">
            <summary>
              Verifies that the ProcessThread instance for a system thread id can
              be determined using the GetProcessThread() method
            </summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestDefaultExceptionHandler">
            <summary>
              Tests whether the afine thread pool's default exception handler works
              as expected
            </summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestWaitingWorkItemsProperty">
            <summary>
              Verifies that the waiting work items count and active thread count are
              updated by the thread pool.
            </summary>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPoolTest.TestTask">
            <summary>ThreadPool task that can be used for testing</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestTask.#ctor">
            <summary>Initializes a new test task</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestTask.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestTask.Callback(System.Object)">
            <summary>Callback that can be added to the thread pool as a task</summary>
            <param name="state">User defined state</param>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPoolTest.TestTask.LastCallbackState">
            <summary>
              State parameter that was provide when the callback was called
            </summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPoolTest.TestTask.callbackEvent">
            <summary>Event that will be set when the callback is invoked</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPoolTest.TestTask.CallbackEvent">
            <summary>Event that will be set when the callback is executed</summary>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPoolTest.WaitTask">
            <summary>ThreadPool task that can be used for testing</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.WaitTask.#ctor">
            <summary>Initializes a new test task</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.WaitTask.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.WaitTask.Callback(System.Object)">
            <summary>Callback that can be added to the thread pool as a task</summary>
            <param name="state">User defined state</param>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPoolTest.WaitTask.LastCallbackState">
            <summary>
              State parameter that was provide when the callback was called
            </summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPoolTest.WaitTask.startEvent">
            <summary>Event that will be set when the callback has started</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPoolTest.WaitTask.finishEvent">
            <summary>Event that will be set when the callback has finished</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPoolTest.WaitTask.waitEvent">
            <summary>Event used to block the callback</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPoolTest.WaitTask.StartEvent">
            <summary>Event that will be set when the callback has started</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPoolTest.WaitTask.FinishEvent">
            <summary>Event that will be set when the callback has finished</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPoolTest.WaitTask.WaitEvent">
            <summary>Event that blocks the callback</summary>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLine">
            <summary>Parses and stores an application's command line parameters</summary>
            <remarks>
              <para>
                At the time of the creation of this component, there are already several command
                line parsing libraries out there. Most of them, however, do way too much at once
                or at the very least rely on huge, untested clutters of classes and methods to
                arrive at their results.
              </para>
              <para>
                This command line parser does nothing more than represent the command line to
                the application through a convenient interface. It parses a command line and
                extracts the arguments, but doesn't interpret them and or check them for validity.
              </para>
              <para>
                This design promotes simplicity and makes is an ideal building block to create
                actual command line interpreters that connect the parameters to program
                instructions and or fill structures in code.
              </para>
              <para>
                Terminology
                <list type="table">
                  <item>
                    <term>Command line</term>
                    <description>
                      The entire command line either as a string or as
                      an already parsed data structure
                    </description>
                  </item>
                  <item>
                    <term>Argument</term>
                    <description>
                      Either an option or a loose value (see below) being specified on
                      the command line
                    </description>
                  </item>
                  <item>
                    <term>Option</term>
                    <description>
                      Can be specified on the command line and typically alters the behavior
                      of the application or changes a setting. For example, '--normalize' or
                      '/safemode'.
                    </description>
                  </item>
                  <item>
                    <term>Value</term>
                    <description>
                      Can either sit loosely in the command line (eg. 'update' or 'textfile.txt')
                      or as assignment to an option (eg. '--width=1280' or '/overwrite:always')
                    </description>
                  </item>
                </list>
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.WindowsModeDefault">
            <summary>
              Whether the command line should use Windows mode by default
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.#ctor">
            <summary>Initializes a new command line</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.#ctor(System.Boolean)">
            <summary>Initializes a new command line</summary>
            <param name="windowsMode">Whether the / character initiates an argument</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.#ctor(System.Collections.Generic.IList{Nuclex.Support.Parsing.CommandLine.Argument})">
            <summary>Initializes a new command line</summary>
            <param name="argumentList">List containing the parsed arguments</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.#ctor(System.Collections.Generic.IList{Nuclex.Support.Parsing.CommandLine.Argument},System.Boolean)">
            <summary>Initializes a new command line</summary>
            <param name="argumentList">List containing the parsed arguments</param>
            <param name="windowsMode">Whether the / character initiates an argument</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parse(System.String)">
            <summary>Parses the command line arguments from the provided string</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <returns>The parsed command line</returns>
            <remarks>
              You should always pass Environment.CommandLine to this method to avoid
              some problems with the built-in command line tokenizer in .NET
              (which splits '--test"hello world"/v' into '--testhello world/v')
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parse(System.String,System.Boolean)">
            <summary>Parses the command line arguments from the provided string</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <param name="windowsMode">Whether the / character initiates an argument</param>
            <returns>The parsed command line</returns>
            <remarks>
              You should always pass Environment.CommandLine to this methods to avoid
              some problems with the built-in command line tokenizer in .NET
              (which splits '--test"hello world"/v' into '--testhello world/v')
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.HasArgument(System.String)">
            <summary>Returns whether an argument with the specified name exists</summary>
            <param name="name">Name of the argument whose existence will be checked</param>
            <returns>True if an argument with the specified name exists</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddValue(System.String)">
            <summary>Adds a value to the command line</summary>
            <param name="value">Value that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddOption(System.String)">
            <summary>Adds an option to the command line</summary>
            <param name="name">Name of the option that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddOption(System.String,System.String)">
            <summary>Adds an option to the command line</summary>
            <param name="initiator">Initiator that will be used to start the option</param>
            <param name="name">Name of the option that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddAssignment(System.String,System.String)">
            <summary>Adds an option with an assignment to the command line</summary>
            <param name="name">Name of the option that will be added</param>
            <param name="value">Value that will be assigned to the option</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddAssignment(System.String,System.String,System.String)">
            <summary>Adds an option with an assignment to the command line</summary>
            <param name="initiator">Initiator that will be used to start the option</param>
            <param name="name">Name of the option that will be added</param>
            <param name="value">Value that will be assigned to the option</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.ToString">
            <summary>Returns a string that contains the entire command line</summary>
            <returns>The entire command line as a single string</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.indexOfArgument(System.String)">
            <summary>Retrieves the index of the argument with the specified name</summary>
            <param name="name">Name of the argument whose index will be returned</param>
            <returns>
              The index of the indicated argument of -1 if no argument with that name exists
            </returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.requiresQuotes(System.String)">
            <summary>
              Determines whether the string requires quotes to survive the command line
            </summary>
            <param name="value">Value that will be checked for requiring quotes</param>
            <returns>True if the value requires quotes to survive the command line</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.containsWhitespace(System.String)">
            <summary>
              Determines whether the string contains any whitespace characters
            </summary>
            <param name="value">String that will be scanned for whitespace characters</param>
            <returns>True if the provided string contains whitespace characters</returns>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.arguments">
            <summary>Options that were specified on the command line</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.windowsMode">
            <summary>Whether the / character initiates an argument</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Arguments">
            <summary>Options that were specified on the command line</summary>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLine.Formatter">
            <summary>Formats a command line instance into a string</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Formatter.FormatCommandLine(Nuclex.Support.Parsing.CommandLine)">
            <summary>
              Formats all arguments in the provided command line instance into a string
            </summary>
            <param name="commandLine">Command line instance that will be formatted</param>
            <returns>All arguments in the command line instance as a string</returns>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLine.Argument">
            <summary>Argument being specified on an application's command line</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Argument.OptionOnly(Nuclex.Support.StringSegment,System.Int32,System.Int32)">
            <summary>Initializes a new option with only a name</summary>
            <param name="raw">
              String segment with the entire argument as it was given on the command line
            </param>
            <param name="nameStart">Absolute index the argument name starts at</param>
            <param name="nameLength">Number of characters in the option name</param>
            <returns>The newly created option</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Argument.ValueOnly(Nuclex.Support.StringSegment,System.Int32,System.Int32)">
            <summary>Initializes a new argument with only a value</summary>
            <param name="raw">
              String segment with the entire argument as it was given on the command line
            </param>
            <param name="valueStart">Absolute index the value starts at</param>
            <param name="valueLength">Number of characters in the value</param>
            <returns>The newly created option</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Argument.#ctor(Nuclex.Support.StringSegment,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Creates a new option with a name and an assigned value</summary>
            <param name="raw">
              String segment containing the entire option as it was given on the command line
            </param>
            <param name="nameStart">Absolute index the option name starts at</param>
            <param name="nameLength">Number of characters in the option name</param>
            <param name="valueStart">Absolute index the value starts at</param>
            <param name="valueLength">Number of characters in the value</param>
            <returns>The newly created option</returns>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.raw">
            <summary>
              Contains the entire option as it was specified on the command line
            </summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.nameStart">
            <summary>Absolute index in the raw string the option name starts at</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.nameLength">
            <summary>Number of characters in the option name</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.valueStart">
            <summary>Absolute index in the raw string the value starts at</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.valueLength">
            <summary>Number of characters in the value</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Raw">
            <summary>Contains the raw string the command line argument was parsed from</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Initiator">
            <summary>Characters used to initiate this option</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Name">
            <summary>Name of the command line option</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Associator">
            <summary>Characters used to associate a value to this option</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Value">
            <summary>Name of the command line option</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.RawLength">
            <summary>The raw length of the command line argument</summary>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLine.Parser">
            <summary>Parses command line strings</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.#ctor(System.Boolean)">
            <summary>Initializes a new command line parser</summary>
            <param name="windowsMode">Whether the / character initiates an argument</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.Parse(System.String,System.Boolean)">
            <summary>Parses a string containing command line arguments</summary>
            <param name="commandLineString">String that will be parsed</param>
            <param name="windowsMode">Whether the / character initiates an argument</param>
            <returns>The parsed command line arguments from the string</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseFullCommandLine(System.String)">
            <summary>
              Parses the provided string and adds the parameters found to
              the command line representation
            </summary>
            <param name="commandLineString">
              String containing the command line arguments that will be parsed
            </param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseChunk(System.String,System.Int32@)">
            <summary>
              Parses a chunk of characters and adds it as an option or a loose value to
              the command line representation we're building
            </summary>
            <param name="commandLineString">
              String containing the chunk of characters that will be parsed
            </param>
            <param name="index">Index in the string at which to begin parsing</param>
            <returns>The number of characters that were consumed</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parsePotentialOption(System.String,System.Int32,System.Int32@)">
            <summary>Parses a potential command line option</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <param name="initiatorStartIndex">
              Index of the option's initiator ('-' or '--' or '/')
            </param>
            <param name="index">
              Index at which the option name is supposed start (if it's an actual option)
            </param>
            <returns>The number of characters consumed</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parsePotentialOptionAssignment(System.String,System.Int32,System.Int32,System.Int32@)">
            <summary>Parses the value assignment in a command line option</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <param name="initiatorStartIndex">
              Position of the character that started the option
            </param>
            <param name="nameStartIndex">
              Position of the first character in the option's name
            </param>
            <param name="index">Index at which the option name ended</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseOptionValue(System.String,System.Int32,System.Int32,System.Int32@)">
            <summary>Parses the value assignment in a command line option</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <param name="initiatorStartIndex">
              Position of the character that started the option
            </param>
            <param name="nameStartIndex">
              Position of the first character in the option's name
            </param>
            <param name="index">Index at which the option name ended</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseQuotedValue(System.String,System.Int32@)">
            <summary>Parses a quoted value from the input string</summary>
            <param name="commandLineString">String the quoted value is parsed from</param>
            <param name="index">Index at which the quoted value begins</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseNakedValue(System.String,System.Int32@)">
            <summary>Parses a plain, unquoted value from the input string</summary>
            <param name="commandLineString">String containing the value to be parsed</param>
            <param name="index">Index at which the value begins</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.addValue(Nuclex.Support.StringSegment)">
            <summary>Adds a loose value to the command line</summary>
            <param name="value">Value taht will be added</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.isAssignmentCharacter(System.Char)">
            <summary>
              Determines whether the specified character indicates an assignment
            </summary>
            <param name="character">
              Character that will be checked for being an assignemnt
            </param>
            <returns>
              True if the specified character indicated an assignment, otherwise false
            </returns>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Parser.NameEndingCharacters">
            <summary>Characters which end an option name when they are encountered</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Parser.WhitespaceCharacters">
            <summary>Characters the parser considers to be whitespace</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Parser.arguments">
            <summary>Argument list being filled by the parser</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Parser.windowsMode">
            <summary>Whether the '/' character initiates an argument</summary>
        </member>
        <member name="T:Nuclex.Support.Licensing.LicenseKeyTest">
            <summary>Unit test for the license key class</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.DefaultConstructorCanBeUsed">
            <summary>Tests the default constructor of the license key class</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.LicenseKeysCanBeConvertedToGuidsAndBack">
            <summary>Validates the correct translation of keys to GUIDs and back</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.LicenseKeysCanBeModified">
            <summary>Tests whether license keys can be modified without destroying them</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.ParsingInvalidLicenseKeyThrowsArgumentException">
            <summary>Tests whether license keys can be modified without destroying them</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.ReadingInvalidIndexThrowsIndexOutOfRangeException">
            <summary>
              Tests whether an exception is thrown if the indexer of a license key is used
              with an invalid index to retrieve a component of the key
            </summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.WritingInvalidIndexThrowsIndexOutOfRangeException">
            <summary>
              Tests whether an exception is thrown if the indexer of a license key is used
              with an invalid index to set a component of the key
            </summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.LicenseKeyCanBeConvertedToByteArray">
            <summary>
              Verifies that a license key can be converted into a byte array
            </summary>
        </member>
        <member name="T:Nuclex.Support.IO.RingMemoryStreamTest">
            <summary>Unit Test for the ring buffer class</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.Setup">
            <summary>Prepares some test data for the units test methods</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestWriteTooLargeChunk">
            <summary>
              Ensures that the ring buffer blocks write attempts that would exceed its capacity
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestWriteBarelyFittingChunk">
            <summary>
              Ensures that the ring buffer still accepts write attempts that would fill the
              entire buffer in one go.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestWriteSplitBlock">
            <summary>
              Ensures that the ring buffer correctly manages write attempts that have to
              be split at the end of the ring buffer
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestWriteSplitAndLinearBlock">
            <summary>
              Ensures that the ring buffer correctly manages write attempts that write into
              the gap after the ring buffer's data has become split
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestWriteSplitAndLinearTooLargeBlock">
            <summary>
              Ensures that the ring buffer still detects write that would exceed its capacity
              if they write into the gap after the ring buffer's data has become split
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestSplitBlockWrappedRead">
            <summary>Tests whether the ring buffer correctly handles fragmentation</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestSplitBlockLinearRead">
            <summary>Tests whether the ring buffer correctly handles fragmentation</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestEndOfStream">
            <summary>
              Tests whether the ring buffer correctly returns partial data if more
              data is requested than is contained in it.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCapacityIncrease">
            <summary>
              Validates that the ring buffer can extend its capacity without loosing data
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCapacityDecrease">
            <summary>
              Validates that the ring buffer can reduce its capacity without loosing data
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCapacityDecreaseException">
            <summary>
              Checks that an exception is thrown when the ring buffer's capacity is
              reduced so much it would have to give up some of its contained data
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCapacity">
            <summary>Tests whether the Capacity property returns the current capacity</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCanRead">
            <summary>Ensures that the CanRead property returns true</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCanSeek">
            <summary>Ensures that the CanSeek property returns false</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCanWrite">
            <summary>Ensures that the CanWrite property returns true</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestAutoReset">
            <summary>
              Tests whether the auto reset feature works (resets the buffer pointer to the
              left end of the buffer when it gets empty; mainly a performance feature).
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestThrowOnRetrievePosition">
            <summary>
              Verifies that an exception is thrown when the Position property of the ring
              memory stream is used to retrieve the current file pointer position
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestThrowOnAssignPosition">
            <summary>
              Verifies that an exception is thrown when the Position property of the ring
              memory stream is used to modify the current file pointer position
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestThrowOnSeek">
            <summary>
              Verifies that an exception is thrown when the Seek() method of the ring memory
              stream is attempted to be used
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestThrowOnSetLength">
            <summary>
              Verifies that an exception is thrown when the SetLength() method of the ring
              memory stream is attempted to be used
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestFlush">
            <summary>
              Tests the Flush() method of the ring memory stream, which is either a dummy
              implementation or has no side effects
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestLengthOnLinearBlock">
            <summary>
              Tests whether the length property is updated in accordance to the data written
              into the ring memory stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestLengthOnSplitBlock">
            <summary>
              Tests whether the length property is updated in accordance to the data written
              into the ring memory stream when the data is split within the stream
            </summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStreamTest.testBytes">
            <summary>Test data for the ring buffer unit tests</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.TransformingReadOnlyCollection`2">
            <summary>Collection that transforms the contents of another collection.</summary>
            <typeparam name="TContainedItem">
              Type of the items contained in the wrapped collection.
            </typeparam>
            <typeparam name="TExposedItem">
              Type this collection exposes its items as.
            </typeparam>
            <remarks>
              <para>
                This collection is useful if you want to expose the objects of an arbitrary
                collection under a different type. It can be used, for example, to construct
                wrappers for the items in a collection on-the-fly, eliminating the need to
                manage the wrappers in parallel to the real items and improving performance
                by only constructing a wrapper when an item is actually requested.
              </para>
              <para>
                Another common use would be if you have a private collection of a non-public
                type that's derived from some publicly visible type. By using this collection,
                you can return the items under the publicly visible type while still having
                your private collection under the non-public type, eliminating the need to
                downcast each time you need to access elements of the non-public type.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new transforming collection wrapper</summary>
            <param name="items">
              Internal list of items that are transformed into the exposed type when
              accessed through the TransformingReadOnlyCollection.
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.Contains(`1)">
            <summary>
              Determines whether an element is in the TransformingReadOnlyCollection
            </summary>
            <param name="item">
              The object to locate in the TransformingReadOnlyCollection.
              The value can be null for reference types.
            </param>
            <returns>
              True if value is found in the TransformingReadOnlyCollection; otherwise, false.
            </returns>
            <remarks>
              The default implementation of this method is very unoptimized and will
              enumerate all the items in the collection, transforming one after another
              to check whether the transformed item matches the item the user was
              looking for. It is recommended to provide a custom implementation of
              this method, if possible.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.CopyTo(`1[],System.Int32)">
            <summary>
              Copies the entire TransformingReadOnlyCollection to a compatible one-dimensional
              System.Array, starting at the specified index of the target array.
            </summary>
            <param name="array">
              The one-dimensional System.Array that is the destination of the elements copied
              from the TransformingReadOnlyCollection. The System.Array must have
              zero-based indexing.
            </param>
            <param name="index">
              The zero-based index in array at which copying begins.
            </param>
            <exception cref="T:System.ArgumentException">
              Index is equal to or greater than the length of array or the number of elements
              in the source TransformingReadOnlyCollection is greater than the available space
              from index to the end of the destination array.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is less than zero.
            </exception>
            <exception cref="T:System.ArgumentNullException">
              Array is null.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.GetEnumerator">
            <summary>
              Returns an enumerator that iterates through the TransformingReadOnlyCollection.
            </summary>
            <returns>
              An enumerator or the TransformingReadOnlyCollection.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.IndexOf(`1)">
            <summary>
              Searches for the specified object and returns the zero-based index of the
              first occurrence within the entire TransformingReadOnlyCollection.
            </summary>
            <param name="item">
              The object to locate in the TransformingReadOnlyCollection. The value can
              be null for reference types.
            </param>
            <returns>
              The zero-based index of the first occurrence of item within the entire
              TransformingReadOnlyCollection, if found; otherwise, -1.
            </returns>
            <remarks>
              The default implementation of this method is very unoptimized and will
              enumerate all the items in the collection, transforming one after another
              to check whether the transformed item matches the item the user was
              looking for. It is recommended to provide a custom implementation of
              this method, if possible.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.Transform(`0)">
            <summary>Transforms an item into the exposed type</summary>
            <param name="item">Item to be transformed</param>
            <returns>The transformed item</returns>
            <remarks>
              This method is used to transform an item in the wrapped collection into
              the exposed item type whenever the user accesses an item. Expect it to
              be called frequently, because the TransformingReadOnlyCollection does
              not cache or otherwise store the transformed items.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.items">
            <summary>Items being transformed upon exposure by this collection</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.syncRoot">
            <summary>Synchronization root for threaded accesses to this collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#IList{TExposedItem}#Insert(System.Int32,`1)">
            <summary>
              Inserts an item to the TransformingReadOnlyCollection at the specified index.
            </summary>
            <param name="index">
              The zero-based index at which item should be inserted.
            </param>
            <param name="item">
              The object to insert into the TransformingReadOnlyCollection
            </param>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#IList{TExposedItem}#RemoveAt(System.Int32)">
            <summary>
              Removes the TransformingReadOnlyCollection item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#ICollection{TExposedItem}#Add(`1)">
            <summary>Adds an item to the TransformingReadOnlyCollection.</summary>
            <param name="item">The object to add to the TransformingReadOnlyCollection</param>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#ICollection{TExposedItem}#Clear">
            <summary>Removes all items from the TransformingReadOnlyCollection</summary>
            <exception cref="T:System.NotSupportedException">
               The TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#ICollection{TExposedItem}#Remove(`1)">
            <summary>
              Removes the first occurrence of a specific object from the
              TransformingReadOnlyCollection.
            </summary>
            <param name="item">
              The object to remove from the TransformingReadOnlyCollection
            </param>
            <returns>
              True if item was successfully removed from the TransformingReadOnlyCollection;
              otherwise, false. This method also returns false if item is not found in the
              original TransformingReadOnlyCollection.
            </returns>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>
              A System.Collections.IEnumerator object that can be used to iterate through
              the collection.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the TransformingReadOnlyCollection.</summary>
            <param name="value">
              The System.Object to add to the TransformingReadOnlyCollection.
            </param>
            <returns>The position into which the new element was inserted.</returns>
            <exception cref="T:System.NotSupportedException">
              The System.Collections.IList is read-only or the TransformingReadOnlyCollection
              has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Clear">
            <summary>Removes all items from the TransformingReadOnlyCollection.</summary>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Contains(System.Object)">
            <summary>
              Determines whether the TransformingReadOnlyCollection contains a specific value.
            </summary>
            <param name="value">
              The System.Object to locate in the TransformingReadOnlyCollection.
            </param>
            <returns>
              True if the System.Object is found in the TransformingReadOnlyCollection;
              otherwise, false.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#IndexOf(System.Object)">
            <summary>
              Determines the index of a specific item in the TransformingReadOnlyCollection.
            </summary>
            <param name="value">
              The System.Object to locate in the TransformingReadOnlyCollection.
            </param>
            <returns>
              The index of value if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
              Inserts an item to the TransformingReadOnlyCollection at the specified index.
            </summary>
            <param name="index">
              The zero-based index at which value should be inserted.
            </param>
            <param name="value">
              The System.Object to insert into the TransformingReadOnlyCollection.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
            <exception cref="T:System.NotSupportedException">
              The System.Collections.IList is read-only or the TransformingReadOnlyCollection
              has a fixed size.
            </exception>
            <exception cref="T:System.NullReferenceException">
              Value is null reference in the TransformingReadOnlyCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Remove(System.Object)">
            <summary>
              Removes the first occurrence of a specific object from the
              TransformingReadOnlyCollection.
            </summary>
            <param name="value">
              The System.Object to remove from the TransformingReadOnlyCollection.
            </param>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only or the
              TransformingReadOnlyCollection has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>
              Removes the TransformingReadOnlyCollection item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only or the
              TransformingReadOnlyCollection has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
              Copies the elements of the TransformingReadOnlyCollection to an System.Array,
              starting at a particular System.Array index.
            </summary>
            <param name="array">
              The one-dimensional System.Array that is the destination of the elements
              copied from TransformingReadOnlyCollection. The System.Array must have zero-based
              indexing.
            </param>
            <param name="index">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
              Array is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is less than zero.
            </exception>
            <exception cref="T:System.ArgumentException">
              Array is multidimensional or index is equal to or greater than the length
              of array or the number of elements in the source TransformingReadOnlyCollection
              is greater than the available space from index to the end of the destination
              array.
            </exception>
            <exception cref="T:System.InvalidCastException">
              The type of the source TransformingReadOnlyCollection cannot be cast
              automatically to the type of the destination array.
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.Count">
            <summary>
              The number of elements contained in the TransformingReadOnlyCollection instance
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.Item(System.Int32)">
            <summary>Gets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
               Index is less than zero or index is equal to or greater than
               TransformingReadOnlyCollection.Count.
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.IsReadOnly">
            <summary>Whether the List is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#IList{TExposedItem}#Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
            <exception cref="T:System.NotSupportedException">
              The property is set and the TransformingReadOnlyCollection is read-only
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#IsFixedSize">
            <summary>
              A value indicating whether the TransformingReadOnlyCollection has a fixed
              size.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection
            </exception>
            <exception cref="T:System.NotSupportedException">
              The property is set and the TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#ICollection#Count">
            <summary>
              The number of elements contained in the TransformingReadOnlyCollection.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#ICollection#IsSynchronized">
            <summary>
              A value indicating whether access to the TransformingReadOnlyCollection
              is synchronized (thread safe).
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#ICollection#SyncRoot">
            <summary>
              An object that can be used to synchronize access to the
              TransformingReadOnlyCollection.
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator">
            <summary>
              An enumerator that transforms the items returned by an enumerator of the
              wrapped collection into the exposed type on-the-fly.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.#ctor(Nuclex.Support.Collections.TransformingReadOnlyCollection{`0,`1},System.Collections.Generic.IEnumerator{`0})">
            <summary>Initializes a new transforming enumerator</summary>
            <param name="transformer">Owner; used to invoke the Transform() method</param>
            <param name="containedTypeEnumerator">Enumerator of the wrapped collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.Dispose">
            <summary>Immediately releases all resources used by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.MoveNext">
            <summary>Gets the current element in the collection.</summary>
            <returns>The current element in the collection.</returns>
            <exception cref="T:System.InvalidOperationException">
              The enumerator is positioned before the first element of the collection
              or after the last element.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.Reset">
            <summary>
              Sets the enumerator to its initial position, which is before the first element
              in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
              The collection was modified after the enumerator was created.
            </exception>
        </member>
        <member name="F:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.transformer">
            <summary>
              Collection that owns this enumerator; required to invoke the item
              transformation method.
            </summary>
        </member>
        <member name="F:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.containedTypeEnumerator">
            <summary>An enumerator from the wrapped collection</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.Current">
            <summary>
              The element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.System#Collections#IEnumerator#Current">
            <summary>The current element in the collection.</summary>
            <exception cref="T:System.InvalidOperationException">
              The enumerator is positioned before the first element of the collection
              or after the last element.
            </exception>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyList`1">
            <summary>Wraps a list and prevents users from modifying it</summary>
            <typeparam name="TItem">Type of items to manage in the set</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new read-only List wrapper</summary>
            <param name="list">List that will be wrapped</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.IndexOf(`0)">
            <summary>Retrieves the index of an item within the List</summary>
            <param name="item">Item whose index will be returned</param>
            <returns>The zero-based index of the specified item in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.Contains(`0)">
            <summary>Determines whether the List contains the specified item</summary>
            <param name="item">Item that will be checked for</param>
            <returns>True if the specified item is contained in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the List into an array</summary>
            <param name="array">Array the List will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.GetEnumerator">
            <summary>Returns a new enumerator over the contents of the list</summary>
            <returns>The new list content enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#IList{TItem}#Insert(System.Int32,`0)">
            <summary>Inserts an item into the list</summary>
            <param name="index">Zero-based index before which the item will be inserted</param>
            <param name="item">Item that will be inserted into the list</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#IList{TItem}#RemoveAt(System.Int32)">
            <summary>Removes an item from the list</summary>
            <param name="index">Zero-based index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#ICollection{TItem}#Add(`0)">
            <summary>Adds an item to the end of the list</summary>
            <param name="item">Item that will be added to the list</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#ICollection{TItem}#Clear">
            <summary>Removes all items from the List</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#ICollection{TItem}#Remove(`0)">
            <summary>Removes the specified item from the list</summary>
            <param name="item">Item that will be removed from the list</param>
            <returns>True of the specified item was found in the list and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new enumerator over the contents of the list</summary>
            <returns>The new list content enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Clear">
            <summary>Removes all items from the list</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the end of the list</summary>
            <param name="value">Item that will be added to the list</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Contains(System.Object)">
            <summary>Determines whether the List contains the specified item</summary>
            <param name="value">Item that will be checked for</param>
            <returns>True if the specified item is contained in the list</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>Retrieves the index of an item within the list</summary>
            <param name="value">Item whose index will be returned</param>
            <returns>The zero-based index of the specified item in the list</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>Inserts an item into the list</summary>
            <param name="index">Zero-based index before which the item will be inserted</param>
            <param name="value">Item that will be inserted into the list</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Remove(System.Object)">
            <summary>Removes the specified item from the list</summary>
            <param name="value">Item that will be removed from the list</param>
            <returns>True of the specified item was found in the list and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>Removes an item from the list</summary>
            <param name="index">Zero-based index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the list into an array</summary>
            <param name="array">Array the list will be copied into</param>
            <param name="index">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyList`1.typedList">
            <summary>The wrapped list under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyList`1.objectList">
            <summary>The wrapped list under its object interface</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.Item(System.Int32)">
            <summary>Accesses the List item with the specified index</summary>
            <param name="index">Zero-based index of the List item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.Count">
            <summary>The number of items current contained in the list</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.IsReadOnly">
            <summary>Whether the list is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#IList{TItem}#Item(System.Int32)">
            <summary>Accesses the list item with the specified index</summary>
            <param name="index">Zero-based index of the list item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#IsFixedSize">
            <summary>Whether the size of the list is fixed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Item(System.Int32)">
            <summary>Accesses the list item with the specified index</summary>
            <param name="index">Zero-based index of the list item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the list is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the list locks</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyDictionary`2">
            <summary>Wraps a dictionary and prevents users from modifying it</summary>
            <typeparam name="KeyType">Type of the keys used in the dictionary</typeparam>
            <typeparam name="ValueType">Type of the values used in the dictionary</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the System.WeakReference class, using deserialized
              data from the specified serialization and stream objects.
            </summary>
            <param name="info">
              An object that holds all the data needed to serialize or deserialize the
              current System.WeakReference object.
            </param>
            <param name="context">
              (Reserved) Describes the source and destination of the serialized stream
              specified by info.
            </param>
            <exception cref="T:System.ArgumentNullException">
              The info parameter is null.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>Initializes a new read-only dictionary wrapper</summary>
            <param name="dictionary">Dictionary that will be wrapped</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
              Determines whether the specified KeyValuePair is contained in the Dictionary
            </summary>
            <param name="item">KeyValuePair that will be checked for</param>
            <returns>True if the provided KeyValuePair was contained in the Dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the Dictionary contains the specified key</summary>
            <param name="key">Key that will be checked for</param>
            <returns>
              True if an entry with the specified key was contained in the Dictionary
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.GetEnumerator">
            <summary>Creates a new enumerator for the Dictionary</summary>
            <returns>The new Dictionary enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
              Attempts to retrieve the item with the specified key from the Dictionary
            </summary>
            <param name="key">Key of the item to attempt to retrieve</param>
            <param name="value">
              Output parameter that will receive the key upon successful completion
            </param>
            <returns>
              True if the item was found and has been placed in the output parameter
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{KeyType@ValueType}#Add(`0,`1)">
            <summary>Inserts an item into the Dictionary</summary>
            <param name="key">Key under which to add the new item</param>
            <param name="value">Item that will be added to the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{KeyType@ValueType}#Remove(`0)">
            <summary>Removes the item with the specified key from the Dictionary</summary>
            <param name="key">Key of the elementes that will be removed</param>
            <returns>True if an item with the specified key was found and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new object enumerator for the Dictionary</summary>
            <returns>The new object enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>Adds an item into the Dictionary</summary>
            <param name="key">Key under which the item will be added</param>
            <param name="value">Item that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>Determines whether the specified key exists in the Dictionary</summary>
            <param name="key">Key that will be checked for</param>
            <returns>True if an item with the specified key exists in the Dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>Removes an item from the Dictionary</summary>
            <param name="key">Key of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>Returns a new entry enumerator for the dictionary</summary>
            <returns>The new entry enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Inserts an already prepared element into the Dictionary</summary>
            <param name="item">Prepared element that will be added to the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Removes all items from the Dictionary</summary>
            <param name="itemToRemove">Item that will be removed from the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary contents will be copied into</param>
            <param name="index">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Serializes the Dictionary</summary>
            <param name="info">
              Provides the container into which the Dictionary will serialize itself
            </param>
            <param name="context">
              Contextual informations about the serialization environment
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)">
            <summary>Called after all objects have been successfully deserialized</summary>
            <param name="sender">Nicht unterstützt</param>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyDictionary`2.typedDictionary">
            <summary>The wrapped Dictionary under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyDictionary`2.objectDictionary">
            <summary>The wrapped Dictionary under its object interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyDictionary`2.readonlyKeyCollection">
            <summary>ReadOnly wrapper for the keys collection of the Dictionary</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyDictionary`2.readonlyValueCollection">
            <summary>ReadOnly wrapper for the values collection of the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.IsReadOnly">
            <summary>Whether the directory is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.Count">
            <summary>Number of elements contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.Keys">
            <summary>Collection of all keys contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.Values">
            <summary>Collection of all values contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.Item(`0)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{KeyType@ValueType}#Item(`0)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>Whether the size of the Dictionary is fixed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Keys">
            <summary>Returns a collection of all keys in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Values">
            <summary>Returns a collection of all values stored in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
            <returns>The item with the specified key</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the Dictionary is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the Dictionary locks</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyDictionary`2.SerializedDictionary">
            <summary>
              Dictionary wrapped used to reconstruct a serialized read only dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.SerializedDictionary.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the System.WeakReference class, using deserialized
              data from the specified serialization and stream objects.
            </summary>
            <param name="info">
              An object that holds all the data needed to serialize or deserialize the
              current System.WeakReference object.
            </param>
            <param name="context">
              (Reserved) Describes the source and destination of the serialized stream
              specified by info.
            </param>
            <exception cref="T:System.ArgumentNullException">
              The info parameter is null.
            </exception>
        </member>
        <member name="T:Nuclex.Support.Collections.ItemReplaceEventArgsTest">
            <summary>Unit Test for the item event argument container</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ItemReplaceEventArgsTest.IntegersCanBeCarried">
            <summary>
              Tests whether an integer argument can be stored in the argument container
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ItemReplaceEventArgsTest.StringsCanBeCarried">
            <summary>
              Tests whether a string argument can be stored in the argument container
            </summary>
        </member>
        <member name="T:Nuclex.Support.TypeHelper">
            <summary>Helper methods for the reflection Type class</summary>
        </member>
        <member name="M:Nuclex.Support.TypeHelper.GetFieldInfosIncludingBaseClasses(System.Type,System.Reflection.BindingFlags)">
            <summary>
              Returns all the fields of a type, including those defined in the type's base classes
            </summary>
            <param name="type">Type whose fields will be returned</param>
            <param name="bindingFlags">Binding flags to use when querying the fields</param>
            <returns>All of the type's fields, including its base types</returns>
        </member>
        <member name="M:Nuclex.Support.TypeHelper.HasDefaultConstructor(System.Type)">
            <summary>Determines whether the given type has a default constructor</summary>
            <param name="type">Type which is to be checked</param>
            <returns>True if the type has a default constructor</returns>
        </member>
        <member name="M:Nuclex.Support.TypeHelper.HasAttribute``1(System.Type)">
            <summary>Determines whether the type has the specified attribute</summary>
            <typeparam name="TAttribute">Attribute the type will be checked for</typeparam>
            <param name="type">
              Type that will be checked for presence of the specified attribute
            </param>
            <returns>True if the type has the specified attribute, otherwise false</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nuclex.Support.TypeHelper.HasAttribute(System.Type,System.Type)" -->
        <member name="T:Nuclex.Support.TypeHelper.FieldInfoComparer">
            <summary>Determines whether member informations relate to the same member</summary>
        </member>
        <member name="F:Nuclex.Support.TypeHelper.FieldInfoComparer.Default">
            <summary>Default instance of the comparer</summary>
        </member>
        <member name="M:Nuclex.Support.TypeHelper.FieldInfoComparer.Equals(System.Reflection.FieldInfo,System.Reflection.FieldInfo)">
            <summary>Checks whether two member informations are equal</summary>
            <param name="left">Informations about the left member in the comaprison</param>
            <param name="right">Informations about the right member in the comparison</param>
            <returns>True if the two member informations relate to the same member</returns>
        </member>
        <member name="M:Nuclex.Support.TypeHelper.FieldInfoComparer.GetHashCode(System.Reflection.FieldInfo)">
            <summary>Determines the hash code of the specified member informations</summary>
            <param name="FieldInfo">
              Member informations whose hash code will be determined
            </param>
            <returns>The hash code of the specified member informations</returns>
        </member>
        <member name="T:Nuclex.Support.GarbagePolicy">
            <summary>How to behave in in respect to the garbage collector</summary>
        </member>
        <member name="F:Nuclex.Support.GarbagePolicy.Avoid">
            <summary>Avoid feeding the garbage collector whenever possible</summary>
        </member>
        <member name="F:Nuclex.Support.GarbagePolicy.Accept">
            <summary>Accept garbage production</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentingCollectionTest">
            <summary>Unit Test for the Parenting Collection class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestPropagatePreassignedParent">
            <summary>
              Tests whether the parenting collection propagates its parent to an item that
              is added to the collection after the collection's aprent is already assigned
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestPropagateParentChange">
            <summary>
              Tests whether the parenting collection propagates a new parent to all items
              contained in it when its parent is changed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestPropagateParentOnReplace">
            <summary>
              Tests whether the parenting collection propagates its parent to an item that
              is added to the collection after the collection's aprent is already assigned
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestUnsetParentOnRemoveItem">
            <summary>
              Tests whether the parenting collection unsets the parent when an item is removed
              from the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestUnsetParentOnClear">
            <summary>
              Tests whether the parenting collection unsets the parent when all item are
              removed from the collection by clearing it
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestDisposeItems">
            <summary>
              Tests whether the parenting collection calls Dispose() on all contained items
              that implement IDisposable when its DisposeItems() method is called
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentingCollectionTest.TestParentable">
            <summary>Parentable object that can be the child of an int</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.Parentable`1">
            <summary>Base class for objects that can be parented to an owner</summary>
            <typeparam name="TParent">Type of the parent object</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.Parentable`1.OnParentChanged(`0)">
            <summary>Invoked whenever the instance's owner changes</summary>
            <remarks>
              When items are parented for the first time, the oldParent argument will
              be null. Also, if the element is removed from the collection, the
              current parent will be null.
            </remarks>
            <param name="oldParent">Previous owner of the instance</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Parentable`1.SetParent(`0)">
            <summary>Assigns a new parent to this instance</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Parentable`1.parent">
            <summary>Current parent of this object</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Parentable`1.Parent">
            <summary>The parent object that owns this instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestParentable.#ctor">
            <summary>Initializes a new instance of the parentable test class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestParentable.GetParent">
            <summary>The parent object that owns this instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestParentable.Dispose">
            <summary>Immediately releases all resources owned by the item</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ParentingCollectionTest.TestParentable.disposeCalled">
            <summary>Whether Dispose() has been called on this item</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ParentingCollectionTest.TestParentable.DisposeCalled">
            <summary>Whether Dispose() has been called on this item</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentingCollectionTest.TestParentingCollection">
            <summary>Parentable object that can be the child of an int</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentingCollection`2">
            <summary>Collection that automatically assigns an owner to all its elements</summary>
            <remarks>
              This collection automatically assigns a parent object to elements that
              are managed in it. The elements have to derive from the Parentable&lt;&gt;
              base class.
            </remarks>
            <typeparam name="TParent">Type of the parent object to assign to items</typeparam>
            <typeparam name="TItem">Type of the items being managed in the collection</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.Reparent(`0)">
            <summary>Reparents all elements in the collection</summary>
            <param name="parent">New parent to take ownership of the items</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.ClearItems">
            <summary>Clears all elements from the collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.InsertItem(System.Int32,`1)">
            <summary>Inserts a new element into the collection</summary>
            <param name="index">Index at which to insert the element</param>
            <param name="item">Item to be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.RemoveItem(System.Int32)">
            <summary>Removes an element from the collection</summary>
            <param name="index">Index of the element to remove</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.SetItem(System.Int32,`1)">
            <summary>Takes over a new element that is directly assigned</summary>
            <param name="index">Index of the element that was assigned</param>
            <param name="item">New item</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.DisposeItems">
            <summary>Disposes all items contained in the collection</summary>
            <remarks>
              <para>
                This method is intended to support collections that need to dispose their
                items. It will unparent all of the collection's items and call Dispose()
                on any item that implements IDisposable.
              </para>
              <para>
                Do not call this method from your destructor as it will access the
                contained items in order to unparent and to Dispose() them, which leads
                to undefined behavior since the object might have already been collected
                by the GC. Call it only if your object is being manually disposed.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Collections.ParentingCollection`2.parent">
            <summary>Parent this collection currently belongs to</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestParentingCollection.SetParent(System.Int32)">
            <summary>Changes the parent of the collection</summary>
            <param name="parent">New parent to assign to the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestParentingCollection.DisposeItems">
            <summary>Disposes all items contained in the collection</summary>
        </member>
        <member name="T:Nuclex.Support.StringHelperTest">
            <summary>Unit Test for the string helper class</summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestIndexNotOfAny">
            <summary>
              Verifies that the IndexNotOfAny() method works identical to the framework's
              implementation of the IndexOfAny() method, only inverted.
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestIndexNotOfAnyWithStartIndex">
            <summary>
              Verifies that the IndexNotOfAny() method works identical to the framework's
              implementation of the IndexOfAny() method, only inverted, using a start index.
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestLastIndexNotOfAny">
            <summary>
              Verifies that the LastIndexNotOfAny() method works identical to the framework's
              implementation of the LastIndexOfAny() method, only inverted.
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestLastIndexNotOfAnyWithStartIndex">
            <summary>
              Verifies that the LastIndexNotOfAny() method works identical to the framework's
              implementation of the LastIndexOfAny() method, only inverted, using a start index.
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestMultipleCharIndexNotOfAny">
            <summary>
              Verifies that the IndexNotOfAny() method works with multiple characters
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestMultipleCharIndexNotOfAnyWithStartIndex">
            <summary>
              Verifies that the IndexNotOfAny() method works with multiple characters,
              using a start index
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestMultipleCharLastIndexNotOfAny">
            <summary>
              Verifies that the LastIndexNotOfAny() method works with multiple characters
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestMultipleCharLastIndexNotOfAnyWithStartIndex">
            <summary>
              Verifies that the LastIndexNotOfAny() method works with multiple characters,
              using a start index
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestIndexNotOfAnyMatchesOnly">
            <summary>
              Verifies that the IndexNotOfAny() method fails when only matches are found
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestIndexNotOfAnyMatchesOnlyWithStartIndex">
            <summary>
              Verifies that the IndexNotOfAny() method fails when only matches are found,
              using a start index
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestLastIndexNotOfAnyMatchesOnly">
            <summary>
              Verifies that the LastIndexNotOfAny() method fails when only matches are found
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestLastIndexNotOfAnyMatchesOnlyWithStartIndex">
            <summary>
              Verifies that the LastIndexNotOfAny() method fails when only matches are found,
              using a start index
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest">
            <summary>Unit Test for the transforming read only collection wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestCopyConstructor">
            <summary>
              Verifies that the copy constructor of the transforming read only collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestIsReadOnly">
            <summary>Verifies that the IsReadOnly property returns true</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestCopyToArray">
            <summary>
              Verifies that the CopyTo() method of the transforming read only collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnCopyToTooSmallArray">
            <summary>
              Verifies that the CopyTo() method of the transforming read only collection throws
              an exception if the target array is too small to hold the collection's contents
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestContains">
            <summary>
              Checks whether the Contains() method of the transforming read only collection
              is able to determine if the collection contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestIndexOf">
            <summary>
              Checks whether the IndexOf() method of the transforming read only collection
              is able to determine if the index of an item in the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestIndexOfWithNullItemNotContained">
            <summary>
              Checks whether the IndexOf() method of the transforming read only collection
              can cope with queries for 'null' when no 'null' item is contained on it
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestIndexOfWithNullItemContained">
            <summary>
              Checks whether the IndexOf() method of the transforming read only collection
              can cope with queries for 'null' when a 'null' item is contained on it
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestEnumeratorReset">
            <summary>
              Verifies that the Enumerator of the transforming read only collection correctly
              implements the Reset() method
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestRetrieveByIndexer">
            <summary>
              Checks whether the indexer method of the transforming read only collection
              is able to retrieve items from the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnInsertViaGenericIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Insert() method is called via the generic IList&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnRemoveViaGenericIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its RemoveAt() method is called via the generic IList&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestRetrieveByIndexerViaGenericIList">
            <summary>
              Checks whether the indexer method of the transforming read only collection will
              throw an exception if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnReplaceByIndexerViaGenericIList">
            <summary>
              Checks whether the indexer method of the transforming read only collection
              will throw an exception if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnAddViaGenericICollection">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Add() method is called via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnClearViaGenericICollection">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Clear() method is called via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnRemoveViaGenericICollection">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Remove() method is called via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestTypesafeEnumerator">
            <summary>
              Tests whether the typesafe enumerator of the read only collection is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnClearViaIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Clear() method is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnAddViaIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Add() method is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestContainsViaIList">
            <summary>
              Checks whether the Contains() method of the transforming read only collection
              is able to determine if the collection contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestIndexOfViaIList">
            <summary>
              Checks whether the IndexOf() method of the transforming read only collection
              is able to determine if the index of an item in the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnInsertViaIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Insert() method is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestIsFixedSizeViaIList">
            <summary>
              Checks whether the IsFixedSize property of the transforming read only collection
              returns the expected result for a transforming read only collection based on
              a fixed array
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnRemoveViaIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Remove() method is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnRemoveAtViaIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Remove() method is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestRetrieveByIndexerViaIList">
            <summary>
              Checks whether the indexer method of the transforming read only collection
              will throw an exception if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnReplaceByIndexerViaIList">
            <summary>
              Checks whether the indexer method of the transforming read only collection
              will throw an exception if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestCopyToArrayViaICollection">
            <summary>
              Verifies that the CopyTo() method of the transforming read only collection
              works if invoked via the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestSynchronizationOfIListWithoutICollection">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
              on transforming read only collections based on IList&lt;&gt;s that do not
              implement the ICollection interface
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.StringTransformer">
            <summary>Test implementation of a transforming collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.StringTransformer.#ctor(System.Collections.Generic.IList{System.Int32})">
            <summary>Initializes a new int-to-string transforming collection</summary>
            <param name="items">Items the transforming collection will contain</param>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.StringTransformer.Transform(System.Int32)">
            <summary>Transforms an item into the exposed type</summary>
            <param name="item">Item to be transformed</param>
            <returns>The transformed item</returns>
            <remarks>
              This method is used to transform an item in the wrapped collection into
              the exposed item type whenever the user accesses an item. Expect it to
              be called frequently, because the TransformingReadOnlyCollection does
              not cache or otherwise store the transformed items.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentableTest">
            <summary>Unit Test for the Parentable class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentableTest.TestParentAssignment">
            <summary>
              Tests whether a parent can be assigned and then retrieved from
              the parentable object
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentableTest.TestParentChangedNotification">
            <summary>
              Tests whether a parent can be assigned and then retrieved from
              the parentable object
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentableTest.TestParentable">
            <summary>Parentable object that can be the child of an int</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentableTest.TestParentable.#ctor">
            <summary>Initializes a new instance of the parentable test class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentableTest.TestParentable.GetParent">
            <summary>The parent object that owns this instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentableTest.TestParentable.OnParentChanged(System.Int32)">
            <summary>Invoked whenever the instance's owner changes</summary>
            <remarks>
              When items are parented for the first time, the oldParent argument will
              be null. Also, if the element is removed from the collection, the
              current parent will be null.
            </remarks>
            <param name="oldParent">Previous owner of the instance</param>
        </member>
        <member name="F:Nuclex.Support.Collections.ParentableTest.TestParentable.parentChangedCalled">
            <summary>Whether the OnParentChanged method has been called</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ParentableTest.TestParentable.ParentChangedCalled">
            <summary>Whether the OnParentChanged method has been called</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.DequeTest">
            <summary>Unit Test for the double ended queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestAddLast">
            <summary>Verifies that the AddLast() method of the deque is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestAddFirst">
            <summary>Verifies that the AddFirst() method of the deque is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveFirst">
            <summary>
              Verifies that the RemoveFirst() method of the deque is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveLast">
            <summary>
              Verifies that the RemoveLast() method of the deque is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestInsert">
            <summary>Verifies that the Insert() method works in all cases</summary>
            <remarks>
              We have several different cases here that will be tested. The deque can
              shift items to the left or right (depending on which end is closer to
              the insertion point) and the insertion point may fall in an only partially
              occupied block, requiring elaborate index calculations
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestInsertNonNormalized">
            <summary>
              Verifies that the Insert() method works in all cases when the deque doesn't
              start at a block boundary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveAt">
            <summary>Verifies the the RemoveAt() method works in all cases</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveAtNonNormalized">
            <summary>
              Verifies the the RemoveAt() method works in all cases when the deque doesn't
              start at a block boundary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveAtEmptiesLeftBlock">
            <summary>
              Tests whether the RemoveAt() method keeps the state of the deque intact when
              it has to remove a block from the left end of the deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveAtEmptiesRightBlock">
            <summary>
              Tests whether the RemoveAt() method keeps the state of the deque intact when
              it has to remove a block from the right end of the deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnAccessFirstInEmptyDeque">
            <summary>
              Validates that an exception is thrown if the 'First' property is accessed
              in an empty deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnAccessLastInEmptyDeque">
            <summary>
              Validates that an exception is thrown if the 'Last' property is accessed
              in an empty deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnRemoveFirstFromEmptyDeque">
            <summary>
              Validates that an exception is thrown if the first item is attempted to be 
              removed from an empty deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnRemoveLastFromEmptyDeque">
            <summary>
              Validates that an exception is thrown if the last item is attempted to be 
              removed from an empty deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIndexAssignment">
            <summary>
              Verifies that items can be assigned by their index
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnInvalidIndex">
            <summary>
              Verifies that an exception is thrown if an invalid index is accessed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIndexOf(System.Int32)">
            <summary>Tests the IndexOf() method</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIndexOfNonNormalized(System.Int32)">
            <summary>
              Tests the IndexOf() method with the deque not starting at a block boundary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestEnumerator">
            <summary>Verifies that the deque's enumerator works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestObjectEnumerator">
            <summary>Verifies that the deque's enumerator works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnInvalidEnumeratorPosition">
            <summary>
              Verifies that an exception is thrown if the enumerator is accessed in
              an invalid position
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestClearSmallDeque">
            <summary>Tests whether a small deque can be cleared</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestClearLargeDeque">
            <summary>Tests whether a large deque can be cleared</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestAddObject">
            <summary>Verifies that the non-typesafe Add() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnAddIncompatibleObject">
            <summary>
              Tests whether an exception is thrown if the non-typesafe Add() method is
              used to add an incompatible object into the deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestAdd">
            <summary>Verifies that the Add() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestContains">
            <summary>Tests whether the Contains() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestContainsObject">
            <summary>Tests the non-typesafe Contains() method</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIndexOfObject">
            <summary>Tests the non-typesafe Contains() method</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestInsertObject">
            <summary>Tests wether the non-typesafe Insert() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnInsertIncompatibleObject">
            <summary>
              Verifies that an exception is thrown if an incompatible object is inserted
              into the deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIsFixedObject">
            <summary>Validates that the IsFixedObject property is set to false</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIsSynchronized">
            <summary>Validates that the IsSynchronized property is set to false</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestObjectIndexAssignment">
            <summary>
              Verifies that items can be assigned by their index using the non-typesafe
              IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIncompatibleObjectIndexAssignment">
            <summary>
              Tests whether an exception is thrown if an incompatible object is assigned
              to the deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemove">
            <summary>Verifies that the Remove() method is working correctly</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveObject">
            <summary>Tests the non-typesafe remove method</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveIncompatibleObject">
            <summary>
              Tests the non-typesafe remove method used to remove an incompatible object
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIsReadOnly">
            <summary>
              Validates that the IsReadOnly property of the deque returns false
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestCopyToObjectArray">
            <summary>Tests the non-typesafe CopyTo() method</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestCopyToArray">
            <summary>Tests the CopyTo() method</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnCopyToIncompatibleObjectArray">
            <summary>
              Verifies that the non-typesafe CopyTo() method throws an exception if
              the array is of an incompatible type
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnCopyToTooSmallArray">
            <summary>
              Verifies that the CopyTo() method throws an exception if the target array
              is too small
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.createNonNormalizedDeque(System.Int32)">
            <summary>
              Creates a deque whose first element does not coincide with a block boundary
            </summary>
            <param name="count">Number of items the deque will be filled with</param>
            <returns>The newly created deque</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.createDeque(System.Int32)">
            <summary>Creates a deque filled with the specified number of items
            </summary>
            <param name="count">Number of items the deque will be filled with</param>
            <returns>The newly created deque</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyListTest">
            <summary>Unit Test for the read only list wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestCopyConstructor">
            <summary>
              Verifies that the copy constructor of the read only list works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestIsReadOnly">
            <summary>Verifies that the IsReadOnly property returns true</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestCopyToArray">
            <summary>
              Verifies that the CopyTo() of the read only list works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestContains">
            <summary>
              Checks whether the Contains() method of the read only list is able to
              determine if the list contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestIndexOf">
            <summary>
              Checks whether the IndexOf() method of the read only list is able to
              determine if the index of an item in the list
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestRetrieveByIndexer">
            <summary>
              Checks whether the indexer method of the read only list is able to
              retrieve items from the list
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnInsertViaGenericIList">
            <summary>
              Checks whether the read only list will throw an exception if its Insert() method
              is called via the generic IList&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnRemoveViaGenericIList">
            <summary>
              Checks whether the read only list will throw an exception if its RemoveAt() method
              is called via the generic IList&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestRetrieveByIndexerViaGenericIList">
            <summary>
              Checks whether the indexer method of the read only list will throw an exception
              if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnReplaceByIndexerViaGenericIList">
            <summary>
              Checks whether the indexer method of the read only list will throw an exception
              if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnAddViaGenericICollection">
            <summary>
              Checks whether the read only list will throw an exception if its Add() method
              is called via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnClearViaGenericICollection">
            <summary>
              Checks whether the read only list will throw an exception if its Clear() method
              is called via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnRemoveViaGenericICollection">
            <summary>
              Checks whether the read only list will throw an exception if its Remove() method
              is called via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestTypesafeEnumerator">
            <summary>
              Tests whether the typesafe enumerator of the read only list is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnClearViaIList">
            <summary>
              Checks whether the read only list will throw an exception if its Clear() method
              is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnAddViaIList">
            <summary>
              Checks whether the read only list will throw an exception if its Add() method
              is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestContainsViaIList">
            <summary>
              Checks whether the Contains() method of the read only list is able to
              determine if the list contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestIndexOfViaIList">
            <summary>
              Checks whether the IndexOf() method of the read only list is able to
              determine if the index of an item in the list
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnInsertViaIList">
            <summary>
              Checks whether the read only list will throw an exception if its Insert() method
              is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestIsFixedSizeViaIList">
            <summary>
              Checks whether the IsFixedSize property of the read only list returns the
              expected result for a read only list based on a fixed array
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnRemoveViaIList">
            <summary>
              Checks whether the read only list will throw an exception if its Remove() method
              is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnRemoveAtViaIList">
            <summary>
              Checks whether the read only list will throw an exception if its Remove() method
              is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestRetrieveByIndexerViaIList">
            <summary>
              Checks whether the indexer method of the read only list will throw an exception
              if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnReplaceByIndexerViaIList">
            <summary>
              Checks whether the indexer method of the read only list will throw an exception
              if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestCopyToArrayViaICollection">
            <summary>
              Verifies that the CopyTo() of the read only list works if invoked via
              the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PairPriorityQueueTest">
            <summary>Unit Test for the priority queue class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueueTest.TestCount">
            <summary>Tests to ensure the count property is properly updated</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueueTest.TestOrdering">
            <summary>Tests to ensure that the priority collection actually sorts items</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueueTest.TestPeek">
            <summary>Tests to ensure that the priority collection's Peek() method works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueueTest.TestCopyTo">
            <summary>Tests whether the priority collection can copy itself into an array</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueueTest.TestSyncRoot">
            <summary>
              Tests whether the priority collection provides a synchronization root
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueueTest.TestEnumerator">
            <summary>
              Tests whether the priority collection provides a working type-safe enumerator
            </summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.SerializationClonerTest">
            <summary>Unit Test for the binary serializer-based cloner</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationClonerTest.#ctor">
            <summary>Initializes a new unit test suite for the reflection cloner</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationClonerTest.CloningNullYieldsNull">
            <summary>Verifies that cloning a null object simply returns null</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationClonerTest.ClassWithoutDefaultConstructorCanBeCloned">
            <summary>
              Verifies that clones of objects whose class doesn't possess a default constructor
              can be made
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationClonerTest.PrimitiveTypesCanBeCloned">
            <summary>Verifies that clones of primitive types can be created</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationClonerTest.DeepClonesOfArraysCanBeMade">
            <summary>Verifies that deep clones of arrays can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationClonerTest.GenericListsCanBeCloned">
            <summary>Verifies that deep clones of a generic list can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationClonerTest.GenericDictionariesCanBeCloned">
            <summary>Verifies that deep clones of a generic dictionary can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationClonerTest.DeepFieldBasedClonesOfValueTypesCanBeMade">
            <summary>
              Verifies that a field-based deep clone of a value type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationClonerTest.DeepFieldBasedClonesOfReferenceTypesCanBeMade">
            <summary>
              Verifies that a field-based deep clone of a reference type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationClonerTest.DeepPropertyBasedClonesOfValueTypesCanBeMade">
            <summary>
              Verifies that a property-based deep clone of a value type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationClonerTest.DeepPropertyBasedClonesOfReferenceTypesCanBeMade">
            <summary>
              Verifies that a property-based deep clone of a reference type can be performed
            </summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.SerializationClonerTest.cloneFactory">
            <summary>Clone factory being tested</summary>
        </member>
        <member name="T:Nuclex.Support.XmlHelper">
            <summary>Helper routines for handling XML code</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadSchema(System.String)">
            <summary>Loads a schema from a file</summary>
            <param name="schemaPath">Path to the file containing the schema</param>
            <returns>The loaded schema</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadSchema(System.IO.Stream)">
            <summary>Loads a schema from the provided stream</summary>
            <param name="schemaStream">Stream containing the schema that will be loaded</param>
            <returns>The loaded schema</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadSchema(System.IO.TextReader)">
            <summary>Loads a schema from a text reader</summary>
            <param name="schemaReader">Text reader through which the schema can be read</param>
            <returns>The loaded schema</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.TryLoadSchema(System.String,System.Xml.Schema.XmlSchema@)">
            <summary>Attempts to load a schema from a file</summary>
            <param name="schemaPath">Path to the file containing the schema</param>
            <param name="schema">Output parameter that will receive the loaded schema</param>
            <returns>True if the schema was loaded successfully, otherwise false</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.TryLoadSchema(System.IO.Stream,System.Xml.Schema.XmlSchema@)">
            <summary>Attempts to load a schema from the provided stream</summary>
            <param name="schemaStream">Stream containing the schema that will be loaded</param>
            <param name="schema">Output parameter that will receive the loaded schema</param>
            <returns>True if the schema was loaded successfully, otherwise false</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.TryLoadSchema(System.IO.TextReader,System.Xml.Schema.XmlSchema@)">
            <summary>Attempts to load a schema from the provided text reader</summary>
            <param name="schemaReader">Reader from which the schema can be read</param>
            <param name="schema">Output parameter that will receive the loaded schema</param>
            <returns>True if the schema was loaded successfully, otherwise false</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadDocument(System.Xml.Schema.XmlSchema,System.String)">
            <summary>Loads an XML document from a file</summary>
            <param name="schema">Schema to use for validating the XML document</param>
            <param name="documentPath">
              Path to the file containing the XML document that will be loaded
            </param>
            <returns>The loaded XML document</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadDocument(System.Xml.Schema.XmlSchema,System.IO.Stream)">
            <summary>Loads an XML document from a stream</summary>
            <param name="schema">Schema to use for validating the XML document</param>
            <param name="documentStream">
              Stream from which the XML document will be read
            </param>
            <returns>The loaded XML document</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.openFileForSharedReading(System.String)">
            <summary>Opens a file for shared reading</summary>
            <param name="path">Path to the file that will be opened</param>
            <returns>The opened file's stream</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.tryOpenFileForSharedReading(System.String,System.IO.FileStream@)">
            <summary>Opens a file for shared reading</summary>
            <param name="path">Path to the file that will be opened</param>
            <param name="fileStream">
              Output parameter that receives the opened file's stream
            </param>
            <returns>True if the file was opened successfully</returns>
        </member>
        <member name="T:Nuclex.Support.XmlHelper.ValidationEventProcessor">
            <summary>Handles any events occurring when an XML schema is loaded</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.ValidationEventProcessor.OnValidationEvent(System.Object,System.Xml.Schema.ValidationEventArgs)">
            <summary>
              Callback for notifications being sent by the XmlSchema.Read() method
            </summary>
            <param name="sender">Not used</param>
            <param name="arguments">Contains the notification being sent</param>
        </member>
        <member name="F:Nuclex.Support.XmlHelper.ValidationEventProcessor.OccurredException">
            <summary>Exception that has occurred during schema loading</summary>
        </member>
        <member name="T:Nuclex.Support.StringSegmentTest">
            <summary>Unit Test for the strign segment class</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestNullStringInSimpleConstructor">
            <summary>
              Tests whether the default constructor of the StringSegment class throws the
              right exception when being passed 'null' instead of a string
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestEmptyStringInSimpleConstructor">
            <summary>
              Tests whether the simple constructor of the StringSegment class accepts
              an empty string
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestNullStringInFullConstructor">
            <summary>
              Tests whether the full constructor of the StringSegment class throws the
              right exception when being passed 'null' instead of a string
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestEmptyStringInFullConstructor">
            <summary>
              Tests whether the full constructor of the StringSegment class accepts
              an empty string
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestInvalidOffsetInConstructor">
            <summary>
              Tests whether the full constructor of the StringSegment class throws the
              right exception when being passed an invalid start offset
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestInvalidLengthInConstructor">
            <summary>
              Tests whether the full constructor of the StringSegment class throws the
              right exception when being passed an invalid string length
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestExcessiveLengthInConstructor">
            <summary>
              Tests whether the full constructor of the StringSegment class throws the
              right exception when being passed a string length that's too large
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestTextProperty">
            <summary>Tests whether the 'Text' property works as expected</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestOffsetProperty">
            <summary>Tests whether the 'Offset' property works as expected</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestCountProperty">
            <summary>Tests whether the 'Count' property works as expected</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestHashCodeOnDifferingInstances">
            <summary>
              Tests whether two differing instances produce different hash codes
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestHashCodeOnEquivalentInstances">
            <summary>
              Tests whether two equivalent instances produce an identical hash code
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestEqualsOnNull">
            <summary>Tests the equals method performing a comparison against null</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestEqualityOnDifferingInstances">
            <summary>Tests the equality operator with differing instances</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestEqualityOnEquivalentInstances">
            <summary>Tests the equality operator with equivalent instances</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestInequalityOnDifferingInstances">
            <summary>Tests the inequality operator with differing instances</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestInequalityOnEquivalentInstances">
            <summary>Tests the inequality operator with equivalent instances</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestToString">
            <summary>Tests the ToString() method of the string segment</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestToStringWithInvalidString">
            <summary>
              Tests the ToString() method of the string segment with an invalid string
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestToStringWithInvalidOffset">
            <summary>
              Tests the ToString() method of the string segment with an invalid offset
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestToStringWithInvalidCount">
            <summary>
              Tests the ToString() method of the string segment with an invalid count
            </summary>
        </member>
        <member name="T:Nuclex.Support.ObservableHelper">
            <summary>Contains helper methods for observing property changed</summary>
        </member>
        <member name="M:Nuclex.Support.ObservableHelper.GetPropertyName``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>Obtains the name of a property from a lambda expression</summary>
            <param name="property">
              Lambda expression for the property whose name will be returned
            </param>
            <returns>The name of the property contained in the lamba expression</returns>
            <remarks>
              <para>
                This method obtains the textual name of a property specified in a lambda
                expression. By going through a lambda expression, the property will be
                stated as actual code, allowing F2 refactoring to correctly update any
                references to the property when it is renamed.
              </para>
              <example>
                <code>
                  string propertyName = ObservableHelper.GetPropertyName(() => SomeValue);
                  Assert.AreEqual("SomeValue", propertyName);
                </code>
              </example>
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableCollection`1">
            <summary>Collection which fires events when items are added or removed</summary>
            <typeparam name="TItem">Type of items the collection manages</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.#ctor">
            <summary>Initializes a new ObservableCollection with no items</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
              Initializes a new ObservableCollection as a wrapper for an existing collection
            </summary>
            <param name="collection">Collection that will be wrapped</param>
            <exception cref="T:System.ArgumentNullException">List is null</exception>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.Clear">
            <summary>Removes all elements from the Collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.Add(`0)">
            <summary>Adds an item to the collection</summary>
            <param name="item">Collection an item will be added to</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.Contains(`0)">
            <summary>Determines whether the collection contains the specified item</summary>
            <param name="item">Item the collection will be searched for</param>
            <returns>
              True if the collection contains the specified item, false otherwise
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the collection into an array</summary>
            <param name="array">Array the collection's contents will be copied into</param>
            <param name="arrayIndex">
              Index in the array where the collection's first item will be placed
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.Remove(`0)">
            <summary>Removes an item from the collection</summary>
            <param name="item">Item that will be removed from the collection</param>
            <returns>True if the item was found and removed, false otherwise</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.GetEnumerator">
            <summary>Returns an enumerator for the items in the collection</summary>
            <returns>An enumeration for the items in the collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.OnAdded(`0)">
            <summary>Fires the 'ItemAdded' event</summary>
            <param name="item">Item that has been added to the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.OnRemoved(`0)">
            <summary>Fires the 'ItemRemoved' event</summary>
            <param name="item">Item that has been removed from the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.OnClearing">
            <summary>Fires the 'Clearing' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.OnCleared">
            <summary>Fires the 'Cleared' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator for the items in the collection</summary>
            <returns>An enumeration for the items in the collection</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the collection into an array</summary>
            <param name="array">Array the collection's contents will be copied into</param>
            <param name="arrayIndex">
              Index in the array where the collection's first item will be placed
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableCollection`1.typedCollection">
            <summary>The wrapped collection under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableCollection`1.objectCollection">
            <summary>The wrapped collection under its object interface</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.ItemAdded">
            <summary>Raised when an item has been added to the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.ItemRemoved">
            <summary>Raised when an item is removed from the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.ItemReplaced">
            <summary>Raised when an item is replaced in the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.Clearing">
            <summary>Raised when the collection is about to be cleared</summary>
            <remarks>
              This could be covered by calling ItemRemoved for each item currently
              contained in the collection, but it is often simpler and more efficient
              to process the clearing of the entire collection as a special operation.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.Cleared">
            <summary>Raised when the collection has been cleared</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.CollectionChanged">
            <summary>Called when the collection has changed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableCollection`1.Count">
            <summary>The total number of items currently in the collection</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableCollection`1.IsReadOnly">
            <summary>Whether the collection is read-only</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the collection synchronizes accesses from multiple threads</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>
              Synchronization root used to synchronize threads accessing the collection
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ItemEventArgs`1">
            <summary>
              Argument container used by collections to notify about changed items
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ItemEventArgs`1.#ctor(`0)">
            <summary>Initializes a new event arguments supplier</summary>
            <param name="item">Item to be supplied to the event handler</param>
        </member>
        <member name="F:Nuclex.Support.Collections.ItemEventArgs`1.item">
            <summary>Item to be passed to the event handler</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ItemEventArgs`1.Item">
            <summary>Obtains the collection item the event arguments are carrying</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.SerializationCloner">
            <summary>Clones objects via serialization</summary>
            <remarks>
              <para>
                This type of cloning uses the binary formatter to persist the state of
                an object and then restores it into a clone. It has the advantage of even
                working with types that don't provide a default constructor, but is
                terribly slow.
              </para>
              <para>
                Inspired by the "A Generic Method for Deep Cloning in C# 3.0" article
                on CodeProject: http://www.codeproject.com/KB/cs/generic_deep_cloning.aspx
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.#cctor">
            <summary>Initializes the static members of the serialization-based cloner</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.DeepFieldClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.DeepPropertyClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.Nuclex#Support#Cloning#ICloneFactory#ShallowFieldClone``1(``0)">
            <summary>
              Creates a shallow clone of the specified object, reusing any referenced objects
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A shallow clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.Nuclex#Support#Cloning#ICloneFactory#ShallowPropertyClone``1(``0)">
            <summary>
              Creates a shallow clone of the specified object, reusing any referenced objects
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A shallow clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.Nuclex#Support#Cloning#ICloneFactory#DeepFieldClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.Nuclex#Support#Cloning#ICloneFactory#DeepPropertyClone``1(``0)">
            <summary>
              Creates a deep clone of the specified object, also creating clones of all
              child objects being referenced
            </summary>
            <typeparam name="TCloned">Type of the object that will be cloned</typeparam>
            <param name="objectToClone">Object that will be cloned</param>
            <returns>A deep clone of the provided object</returns>
        </member>
        <member name="F:Nuclex.Support.Cloning.SerializationCloner.fieldBasedFormatter">
            <summary>Serializes objects by storing their fields</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.SerializationCloner.propertyBasedFormatter">
            <summary>Serializes objects by storing their properties</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.SerializationCloner.StaticSurrogateSelector">
            <summary>Selects a static surrogate for any non-primitive types</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.StaticSurrogateSelector.#ctor(System.Runtime.Serialization.ISerializationSurrogate)">
            <summary>Initializes a new static surrogate selector</summary>
            <param name="staticSurrogate">Surrogate that will be selected</param>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.StaticSurrogateSelector.ChainSelector(System.Runtime.Serialization.ISurrogateSelector)">
            <summary>
              Sets the next selector to escalate to if this one can't provide a surrogate
            </summary>
            <param name="selector">Selector to escalate to</param>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.StaticSurrogateSelector.GetNextSelector">
            <summary>
              Returns the selector this one will escalate to if it can't provide a surrogate
            </summary>
            <returns>The selector this one will escalate to</returns>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.StaticSurrogateSelector.GetSurrogate(System.Type,System.Runtime.Serialization.StreamingContext,System.Runtime.Serialization.ISurrogateSelector@)">
            <summary>Attempts to provides a surrogate for the specified type</summary>
            <param name="type">Type a surrogate will be provided for</param>
            <param name="context">Context </param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="F:Nuclex.Support.Cloning.SerializationCloner.StaticSurrogateSelector.staticSurrogate">
            <summary>Surrogate the that will be selected for any non-primitive types</summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.SerializationCloner.StaticSurrogateSelector.chainedSelector">
            <summary>Surrogate selector to escalate to if no surrogate can be provided</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.SerializationCloner.FieldSerializationSurrogate">
            <summary>Serializes a type based on its fields</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.FieldSerializationSurrogate.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Extracts the data to be serialized from an object</summary>
            <param name="objectToSerialize">Object that is being serialized</param>
            <param name="info">Stores the serialized informations</param>
            <param name="context">
              Provides additional informations about the serialization process
            </param>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.FieldSerializationSurrogate.SetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Runtime.Serialization.ISurrogateSelector)">
            <summary>Reinserts saved data into a deserializd object</summary>
            <param name="deserializedObject">Object the saved data will be inserted into</param>
            <param name="info">Contains the serialized informations</param>
            <param name="context">
              Provides additional informations about the serialization process
            </param>
            <param name="selector">Surrogate selector that specified this surrogate</param>
            <returns>The deserialized object</returns>
        </member>
        <member name="T:Nuclex.Support.Cloning.SerializationCloner.PropertySerializationSurrogate">
            <summary>Serializes a type based on its properties</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.PropertySerializationSurrogate.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Extracts the data to be serialized from an object</summary>
            <param name="objectToSerialize">Object that is being serialized</param>
            <param name="info">Stores the serialized informations</param>
            <param name="context">
              Provides additional informations about the serialization process
            </param>
        </member>
        <member name="M:Nuclex.Support.Cloning.SerializationCloner.PropertySerializationSurrogate.SetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Runtime.Serialization.ISurrogateSelector)">
            <summary>Reinserts saved data into a deserializd object</summary>
            <param name="deserializedObject">Object the saved data will be inserted into</param>
            <param name="info">Contains the serialized informations</param>
            <param name="context">
              Provides additional informations about the serialization process
            </param>
            <param name="selector">Surrogate selector that specified this surrogate</param>
            <returns>The deserialized object</returns>
        </member>
        <member name="T:Nuclex.Support.Shared`1">
            <summary>Manages a globally shared instance of the given Type</summary>
            <typeparam name="TShared">
              Type of which a globally shared instance will be provided
            </typeparam>
        </member>
        <member name="F:Nuclex.Support.Shared`1.instance">
            <summary>Stored the globally shared instance</summary>
        </member>
        <member name="P:Nuclex.Support.Shared`1.Instance">
            <summary>Returns the global instance of the class</summary>
        </member>
        <member name="T:Nuclex.Support.IntegerHelper">
            <summary>Helper methods for working with integer types</summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.NextPowerOf2(System.Int64)">
            <summary>Returns the next highest power of 2 from the specified value</summary>
            <param name="value">Value of which to return the next highest power of 2</param>
            <returns>The next highest power of 2 to the value</returns>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.NextPowerOf2(System.UInt64)">
            <summary>Returns the next highest power of 2 from the specified value</summary>
            <param name="value">Value of which to return the next highest power of 2</param>
            <returns>The next highest power of 2 to the value</returns>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.NextPowerOf2(System.Int32)">
            <summary>Returns the next highest power of 2 from the specified value</summary>
            <param name="value">Value of which to return the next highest power of 2</param>
            <returns>The next highest power of 2 to the value</returns>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.NextPowerOf2(System.UInt32)">
            <summary>Returns the next highest power of 2 from the specified value</summary>
            <param name="value">Value of which to return the next highest power of 2</param>
            <returns>The next highest power of 2 to the value</returns>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.CountBits(System.Int32)">
            <summary>Returns the number of bits set in an </summary>
            <param name="value">Value whose bits will be counted</param>
            <returns>The number of bits set in the integer</returns>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.CountBits(System.UInt32)">
            <summary>Returns the number of bits set in an unsigned integer</summary>
            <param name="value">Value whose bits will be counted</param>
            <returns>The number of bits set in the unsigned integer</returns>
            <remarks>
              Based on a trick revealed here:
              http://stackoverflow.com/questions/109023
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.CountBits(System.Int64)">
            <summary>Returns the number of bits set in a long integer</summary>
            <param name="value">Value whose bits will be counted</param>
            <returns>The number of bits set in the long integer</returns>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.CountBits(System.UInt64)">
            <summary>Returns the number of bits set in an unsigned long integer</summary>
            <param name="value">Value whose bits will be counted</param>
            <returns>The number of bits set in the unsigned long integer</returns>
            <remarks>
              Based on a trick revealed here:
              http://stackoverflow.com/questions/2709430
            </remarks>
        </member>
        <member name="T:Nuclex.Support.FloatHelper">
            <summary>Helper routines for working with floating point numbers</summary>
            <remarks>
              <para>
                The floating point comparison code is based on this excellent article:
                http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
              </para>
              <para>
                "ULP" means Unit in the Last Place and in the context of this library refers to
                the distance between two adjacent floating point numbers. IEEE floating point
                numbers can only represent a finite subset of natural numbers, with greater
                accuracy for smaller numbers and lower accuracy for very large numbers.
              </para>
              <para>
                If a comparison is allowed "2 ulps" of deviation, that means the values are
                allowed to deviate by up to 2 adjacent floating point values, which might be
                as low as 0.0000001 for small numbers or as high as 10.0 for large numbers.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.AreAlmostEqual(System.Single,System.Single,System.Int32)">
            <summary>Compares two floating point values for equality</summary>
            <param name="left">First floating point value to be compared</param>
            <param name="right">Second floating point value t be compared</param>
            <param name="maxUlps">
              Maximum number of representable floating point values that are allowed to
              be between the left and the right floating point values
            </param>
            <returns>True if both numbers are equal or close to being equal</returns>
            <remarks>
              <para>
                Floating point values can only represent a finite subset of natural numbers.
                For example, the values 2.00000000 and 2.00000024 can be stored in a float,
                but nothing inbetween them.
              </para>
              <para>
                This comparison will count how many possible floating point values are between
                the left and the right number. If the number of possible values between both
                numbers is less than or equal to maxUlps, then the numbers are considered as
                being equal.
              </para>
              <para>
                Implementation partially follows the code outlined here (link now defunct):
                http://www.anttirt.net/2007/08/19/proper-floating-point-comparisons/
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.AreAlmostEqual(System.Double,System.Double,System.Int64)">
            <summary>Compares two double precision floating point values for equality</summary>
            <param name="left">First double precision floating point value to be compared</param>
            <param name="right">Second double precision floating point value t be compared</param>
            <param name="maxUlps">
              Maximum number of representable double precision floating point values that are
              allowed to be between the left and the right double precision floating point values
            </param>
            <returns>True if both numbers are equal or close to being equal</returns>
            <remarks>
              <para>
                Double precision floating point values can only represent a limited series of
                natural numbers. For example, the values 2.0000000000000000 and 2.0000000000000004
                can be stored in a double, but nothing inbetween them.
              </para>
              <para>
                This comparison will count how many possible double precision floating point
                values are between the left and the right number. If the number of possible
                values between both numbers is less than or equal to maxUlps, then the numbers
                are considered as being equal.
              </para>
              <para>
                Implementation partially follows the code outlined here:
                http://www.anttirt.net/2007/08/19/proper-floating-point-comparisons/
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.ReinterpretAsInt(System.Single)">
            <summary>
              Reinterprets the memory contents of a floating point value as an integer value
            </summary>
            <param name="value">
              Floating point value whose memory contents to reinterpret
            </param>
            <returns>
              The memory contents of the floating point value interpreted as an integer
            </returns>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.ReinterpretAsLong(System.Double)">
            <summary>
              Reinterprets the memory contents of a double precision floating point
              value as an integer value
            </summary>
            <param name="value">
              Double precision floating point value whose memory contents to reinterpret
            </param>
            <returns>
              The memory contents of the double precision floating point value
              interpreted as an integer
            </returns>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.ReinterpretAsFloat(System.Int32)">
            <summary>
              Reinterprets the memory contents of an integer as a floating point value
            </summary>
            <param name="value">Integer value whose memory contents to reinterpret</param>
            <returns>
              The memory contents of the integer value interpreted as a floating point value
            </returns>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.ReinterpretAsDouble(System.Int64)">
            <summary>
              Reinterprets the memory contents of an integer value as a double precision
              floating point value
            </summary>
            <param name="value">Integer whose memory contents to reinterpret</param>
            <returns>
              The memory contents of the integer interpreted as a double precision
              floating point value
            </returns>
        </member>
        <member name="T:Nuclex.Support.FloatHelper.FloatIntUnion">
            <summary>Union of a floating point variable and an integer</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.FloatIntUnion.Float">
            <summary>The union's value as a floating point variable</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.FloatIntUnion.Int">
            <summary>The union's value as an integer</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.FloatIntUnion.UInt">
            <summary>The union's value as an unsigned integer</summary>
        </member>
        <member name="T:Nuclex.Support.FloatHelper.DoubleLongUnion">
            <summary>Union of a double precision floating point variable and a long</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.DoubleLongUnion.Double">
            <summary>The union's value as a double precision floating point variable</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.DoubleLongUnion.Long">
            <summary>The union's value as a long</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.DoubleLongUnion.ULong">
            <summary>The union's value as an unsigned long</summary>
        </member>
        <member name="T:Nuclex.Support.EnumHelperTest">
            <summary>Unit Test for the enumeration helper class</summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestGetValuesXbox360">
            <summary>
              Verifies that the enum helper can list the members of an enumeration
              manually (as it needs to be done on the XBox 360)
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestGetValues">
            <summary>
              Verifies that the enum helper can list the members of an enumeration
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestGetHighestValue">
            <summary>
              Verifies that the enum helper can locate the highest value in an enumeration
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestGetLowestValue">
            <summary>
              Verifies that the enum helper can locate the lowest value in an enumeration
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestThrowOnNonEnumTypeXbox360">
            <summary>
              Tests whether an exception is thrown if the GetValuesXbox360() method is
              used on a non-enumeration type
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestThrowOnNonEnumType">
            <summary>
              Tests whether an exception is thrown if the GetValues() method is used on
              a non-enumeration type
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestLowestValueInEmptyEnumeration">
            <summary>
              Verifies that the default value for an enumeration is returned if
              the GetLowestValue() method is used on an empty enumeration
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestHighestValueInEmptyEnumeration">
            <summary>
              Verifies that the default value for an enumeration is returned if
              the GetHighestValue() method is used on an empty enumeration
            </summary>
        </member>
        <member name="T:Nuclex.Support.EnumHelperTest.TestEnumeration">
            <summary>An enumeration used for unit testing</summary>
        </member>
        <member name="F:Nuclex.Support.EnumHelperTest.TestEnumeration.One">
            <summary>First arbitrary enumeration value</summary>
        </member>
        <member name="F:Nuclex.Support.EnumHelperTest.TestEnumeration.Three">
            <summary>Third arbitrary enumeration value</summary>
        </member>
        <member name="F:Nuclex.Support.EnumHelperTest.TestEnumeration.Two">
            <summary>Second arbitrary enumeration value</summary>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPool">
            <summary>Alternative Thread pool providing one thread for each core</summary>
            <remarks>
              <para>
                Unlike the normal thread pool, the affine thread pool provides only as many
                threads as there are CPU cores available on the current platform. This makes
                it more suitable for tasks you want to spread across all available cpu cores
                explicitly.
              </para>
              <para>
                However, it's not a good match if you want to run blocking or waiting tasks
                inside the thread pool because the limited available threads will become
                congested quickly. It is encouraged to use this class in parallel with
                .NET's own thread pool, putting tasks that can block into the .NET thread
                pool and task that perform pure processing into the affine thread pool.
              </para>
              <para>
                Implementation based on original code provided by Stephen Toub
                (stoub at microsoft ignorethis dot com)
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.Processors">
            <summary>Number of CPU cores available on the system</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.#cctor">
            <summary>Initializes the thread pool</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
            <summary>Queues a user work item to the thread pool</summary>
            <param name="callback">
              A WaitCallback representing the delegate to invoke when a thread in the 
              thread pool picks up the work item
            </param>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)">
            <summary>Queues a user work item to the thread pool.</summary>
            <param name="callback">
              A WaitCallback representing the delegate to invoke when a thread in the 
              thread pool picks up the work item
            </param>
            <param name="state">
              The object that is passed to the delegate when serviced from the thread pool
            </param>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.DefaultExceptionHandler(System.Exception)">
            <summary>
              Default handler used to respond to unhandled exceptions in ThreadPool threads
            </summary>
            <param name="exception">Exception that has occurred</param>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.GetProcessThread(System.Int32)">
            <summary>Retrieves the ProcessThread for the calling thread</summary>
            <returns>The ProcessThread for the calling thread</returns>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.ProcessQueuedItems">
            <summary>A thread worker function that processes items from the work queue</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.getNextWorkItem">
            <summary>Obtains the next work item from the queue</summary>
            <returns>The next work item in the queue</returns>
            <remarks>
              If the queue is empty, the call will block until an item is added to
              the queue and the calling thread was the one picking it up.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.ExceptionHandler">
            <summary>Delegate used to handle assertion checks in the code</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.GetCurrentThreadId">
            <summary>Retrieves the calling thread's thread id</summary>
            <returns>The thread is of the calling thread</returns>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.hardwareThreads">
            <summary>Available hardware threads the thread pool threads pick from</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.userWorkItems">
            <summary>Queue of all the callbacks waiting to be executed.</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.workAvailable">
            <summary>
              Used to let the threads in the thread pool wait for new work to appear.
            </summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.workerThreads">
            <summary>List of all worker threads at the disposal of the thread pool.</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.inUseThreads">
            <summary>Number of threads currently active.</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPool.MaxThreads">
            <summary>Gets the number of threads at the disposal of the thread pool</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPool.ActiveThreads">
            <summary>Gets the number of currently active threads in the thread pool</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPool.WaitingWorkItems">
            <summary>
              Gets the number of callback delegates currently waiting in the thread pool
            </summary>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPool.ExceptionDelegate">
            <summary>Delegate used by the thread pool to report unhandled exceptions</summary>
            <param name="exception">Exception that has not been handled</param>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPool.UserWorkItem">
            <summary>Used to hold a callback delegate and the state for that delegate.</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.UserWorkItem.#ctor(System.Threading.WaitCallback,System.Object)">
            <summary>Initialize the callback holding object.</summary>
            <param name="callback">Callback delegate for the callback.</param>
            <param name="state">State with which to call the callback delegate.</param>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.UserWorkItem.Callback">
            <summary>Callback delegate for the callback.</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.UserWorkItem.State">
            <summary>State with which to call the callback delegate.</summary>
        </member>
        <member name="T:Nuclex.Support.PropertyChangedEventArgsHelper">
            <summary>Contains helper methods for property change notifications</summary>
        </member>
        <member name="F:Nuclex.Support.PropertyChangedEventArgsHelper.Wildcard">
            <summary>
              A property change event argument container that indicates that all
              properties have changed their value.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PropertyChangedEventArgsHelper.#cctor">
            <summary>Initializes a new property changed argument helper</summary>
        </member>
        <member name="M:Nuclex.Support.PropertyChangedEventArgsHelper.GetArgumentsFor``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
              Provides a property change argument container for the specified property
            </summary>
            <param name="property">
              Property for which an event argument container will be provided
            </param>
            <returns>The event argument container for a property of the specified name</returns>
            <remarks>
              <para>
                This method transparently caches instances of the argument containers
                to avoid feeding the garbage collector. A typical application only has
                in the order of tens to hundreds of different properties for which changes
                will be reported, making a cache to avoid garbage collections viable.
              </para>
              <example>
                <code>
                  PropertyChangedEventArgs arguments =
                    PropertyChangedEventArgsHelper.GetArgumentsFor(() => SomeProperty);
                </code>
              </example>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.PropertyChangedEventArgsHelper.GetArgumentsFor(System.String)">
            <summary>
              Provides a property change argument container for the specified property
            </summary>
            <param name="propertyName">
              Property for which an event argument container will be provided
            </param>
            <returns>The event argument container for a property of the specified name</returns>
            <remarks>
              <para>
                This method transparently caches instances of the argument containers
                to avoid feeding the garbage collector. A typical application only has
                in the order of tens to hundreds of different properties for which changes
                will be reported, making a cache to avoid garbage collections viable.
              </para>
              <example>
                <code>
                  PropertyChangedEventArgs arguments =
                    PropertyChangedEventArgsHelper.GetArgumentsFor("SomeProperty");
                </code>
              </example>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.PropertyChangedEventArgsHelper.AreAffecting``1(System.ComponentModel.PropertyChangedEventArgs,System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
              Determines whether the property change affects the specified property
            </summary>
            <typeparam name="TValue">
              Type of the property that will be tested for being affected
            </typeparam>
            <param name="arguments">
              Property change that has been reported by the observed object
            </param>
            <param name="property">Property that will be tested for being affected</param>
            <returns>Whether the specified property is affected by the property change</returns>
            <remarks>
              <para>
                By using this method, you can shorten the code needed to test whether
                a property change notification affects a specific property. You also
                avoid hardcoding the property name, which would have the adverse effect
                of not updating the textual property names during F2 refactoring.
              </para>
              <example>
                <code>
                  private void propertyChanged(object sender, PropertyChangedEventArgs arguments) {
                    if(arguments.AreAffecting(() => ViewModel.DisplayedValue)) {
                      updateDisplayedValueFromViewModel();
                    } // Do not use else if here or wildcards will not work
                    if(arguments.AreAffecting(() => ViewModel.OtherValue)) {
                      updateOtherValueFromViewModel();
                    }
                  }
                </code>
              </example>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.PropertyChangedEventArgsHelper.AreAffecting(System.ComponentModel.PropertyChangedEventArgs,System.String)">
            <summary>
              Determines whether the property change affects the specified property
            </summary>
            <param name="arguments">
              Property change that has been reported by the observed object
            </param>
            <param name="propertyName">Property that will be tested for being affected</param>
            <returns>Whether the specified property is affected by the property change</returns>
            <remarks>
              <para>
                By using this method, you can shorten the code needed to test whether
                a property change notification affects a specific property.
              </para>
              <example>
                <code>
                  private void propertyChanged(object sender, PropertyChangedEventArgs arguments) {
                    if(arguments.AreAffecting("DisplayedValue")) {
                      updateDisplayedValueFromViewModel();
                    } // Do not use else if here or wildcards will not work
                    if(arguments.AreAffecting("OtherValue")) {
                      updateOtherValueFromViewModel();
                    }
                  }
                </code>
              </example>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.PropertyChangedEventArgsHelper.AffectAllProperties(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Determines whether a property change notification is a wildcard</summary>
            <param name="arguments">
            	Property change notification that will be checked on being a wildcard
            </param>
            <returns>
              Whether the property change is a wildcard, indicating that all properties
              have changed.
            </returns>
            <remarks>
              <para>
                As stated on MSDN: "The PropertyChanged event can indicate all properties
                on the object have changed by using either Nothing or String.Empty as
                the property name in the PropertyChangedEventArgs."
              </para>
              <para>
                This method offers an expressive way of checking for that eventuality.
              </para>
              <example>
                <code>
                  private void propertyChanged(object sender, PropertyChangedEventArgs arguments) {
                    if(arguments.AffectAllProperties()) {
                      // Do something
                    }
                  }
                </code>
              </example>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.PropertyChangedEventArgsHelper.cache">
            <summary>
              Caches PropertyChangedEventArgs instances to avoid feeding the garbage collector
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.WeakCollectionTest">
            <summary>Unit Test for the weak collection wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestConstructor">
            <summary>Verifies that the constructor of the weak collection is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestAddAsObject">
            <summary>
              Test whether the non-typesafe Add() method of the weak collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestThrowOnAddIncompatibleObject">
            <summary>
              Test whether the non-typesafe Add() method throws an exception if an object is
              added that is not compatible to the collection's item type
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestAdd">
            <summary>
              Test whether the generic Add() method of the weak collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestClear">
            <summary>Tests whether the Clear() method works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestContains">
            <summary>Tests whether the Contains() method works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestContainsWithObject">
            <summary>Tests whether the non-typesafe Contains() method works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestEnumeratorReset">
            <summary>
              Verifies that the Enumerator of the dummy collection correctly
              implements the Reset() method
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIndexOf">
            <summary>Verifies that the IndexOf() method is working as intended</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIndexOfWithObject">
            <summary>
              Verifies that the non-typesafe IndexOf() method is working as intended
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestThrowOnIndexOfWithIncompatibleObject">
            <summary>
              Verifies that an exception is thrown if an incompatible object is passed to
              the non-typesafe variant of the IndexOf() method
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIndexOfNull">
            <summary>Test whether the IndexOf() method can cope with null references</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestCopyToArray">
            <summary>
              Verifies that the CopyTo() method of the weak collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestThrowOnCopyToTooSmallArray">
            <summary>
              Verifies that the CopyTo() method of the weak collection throws an exception
              if the target array is too small to hold the collection's contents
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestCopyToArrayViaICollection">
            <summary>
              Verifies that the CopyTo() method of the transforming read only collection
              works if invoked via the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestInsert">
            <summary>
              Verifies that the Insert() method correctly shifts items in the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestInsertObject">
            <summary>
              Verifies that the non-typesafe Insert() method correctly shifts items in
              the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestThrowOnInsertIncompatibleObject">
            <summary>
              Verifies that the non-typesafe Insert() method correctly shifts items in
              the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIsFixedSizeViaIList">
            <summary>
              Checks whether the IsFixedSize property of the weak collection returns
              the expected result for a weak collection based on a fixed array
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIsReadOnly">
            <summary>
              Tests whether the IsReadOnly property of the weak collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIsSynchronized">
            <summary>
              Tests whether the IsSynchronized property of the weak collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIndexer">
            <summary>Tests the indexer of the weak collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIndexerWithObject">
            <summary>Tests the non-typesafe indexer of the weak collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestThrowOnIndexerWithIncompatibleObject">
            <summary>
              Tests whether the non-typesafe indexer of the weak collection throws
              the correct exception if an incompatible object is assigned
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestRemove">
            <summary>Tests the Remove() method of the weak collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestRemoveObject">
            <summary>Tests the non-typesafe Remove() method of the weak collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestRemoveNull">
            <summary>
              Tests whether a null object can be managed by and removed from the weak collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestThrowOnRemoveIncompatibleObject">
            <summary>
              Tests whether the non-typesafe Remove() method of the weak collection throws
              an exception if an object is tried to be removed that is incompatible with
              the collection's item type
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestRemoveAt">
            <summary>Tests the RemoveAt() method of the weak collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestSynchronizationOfIListWithoutICollection">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
              on transforming read only collections based on IList&lt;&gt;s that do not
              implement the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestRemoveDeadItems">
            <summary>Tests the RemoveDeadItems() method</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.WeakCollectionTest.Dummy">
            <summary>Dummy class used to test the weakly referencing collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.Dummy.#ctor(System.Int32)">
            <summary>Initializes a new dummy</summary>
            <param name="value">Value that will be stored by the dummy</param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.Dummy.Equals(System.Object)">
            <summary>
              Determines whether the specified System.Object is equal to
              the current Dummy object.
            </summary>
            <param name="otherAsObject">
              The System.Object to compare with the current Dummy object
            </param>
            <returns>
              True if the specified System.Object is equal to the current Dummy object;
              otherwise, false.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.Dummy.GetHashCode">
            <summary>Serves as a hash function for a particular type.</summary>
            <returns>A hash code for the current System.Object.</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollectionTest.Dummy.Value">
            <summary>Some value that can be used for testing</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReverseComparer`1">
            <summary>
              Compares two values in reverse or reverses the output of another comparer
            </summary>
            <typeparam name="TCompared">Type of values to be compared</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparer`1.#ctor">
            <summary>Initializes a new reverse comparer</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparer`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
              Initializes the comparer to provide the inverse results of another comparer
            </summary>
            <param name="comparerToReverse">Comparer whose results will be inversed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparer`1.Compare(`0,`0)">
            <summary>Compares the left value to the right value</summary>
            <param name="left">Value on the left side</param>
            <param name="right">Value on the right side</param>
            <returns>The relationship of the two values</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.ReverseComparer`1.comparer">
            <summary>The default comparer from the .NET framework</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlySetTest">
            <summary>Unit Test for the observable set wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySetTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySetTest.HasDefaultConstructor">
            <summary>
              Verifies that the observable set has a default constructor
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySetTest.AddingThrowsException">
            <summary>
              Verifies that an exception is thrown upon any attempt to add items
              to a read-only set
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySetTest.RemovingThrowsException">
            <summary>
              Verifies that an exception is thrown upon any attempt to remove items
              from a read-only set
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySetTest.ExceptingThrowsException">
            <summary>
              Verifies that an exception is thrown upon any attempt to except
              the set with another set
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySetTest.InsersectThrowsException">
            <summary>
              Verifies that an exception is thrown upon any attempt to intersect
              the set with another set
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySetTest.CanDetermineProperSubsetAndSuperset">
            <summary>
              Verifies that it's possible to determine whether a set is a proper subset
              or superset of another set
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySetTest.CanDetermineSubsetAndSuperset">
            <summary>
              Verifies that it's possible to determine whether a set is a subset
              or a superset of another set
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySetTest.CanDetermineOverlap">
            <summary>
              Verifies that a set can determine if another set overlaps with it
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySetTest.CanDetermineSetEquality">
            <summary>
              Verifies that a set can determine if another set contains the same elements
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySetTest.SymmetricallyExceptingThrowsException">
            <summary>
              Verifies that any attempt to symmetrically except a read-only set
              causes an exception
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlySetTest.UnioningThrowsException">
            <summary>
              Verifies that any attempt to union a read-only set causes an exception
            </summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlySetTest.set">
            <summary>Set being wrapped in a read-only set</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlySetTest.readOnlySet">
            <summary>Read-only wrapper around the set</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableList`1">
            <summary>List which fires events when items are added or removed</summary>
            <typeparam name="TItem">Type of items the collection manages</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.#ctor">
            <summary>
              Initializes a new instance of the ObservableList class that is empty.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
              Initializes a new instance of the ObservableList class as a wrapper
              for the specified list.
            </summary>
            <param name="list">The list that is wrapped by the new collection.</param>
            <exception cref="T:System.ArgumentNullException">List is null</exception>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.IndexOf(`0)">
            <summary>Determines the index of the specified item in the list</summary>
            <param name="item">Item whose index will be determined</param>
            <returns>The index of the item in the list or -1 if not found</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.Insert(System.Int32,`0)">
            <summary>Inserts an item into the list at the specified index</summary>
            <param name="index">Index the item will be insertted at</param>
            <param name="item">Item that will be inserted into the list</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.RemoveAt(System.Int32)">
            <summary>Removes the item at the specified index from the list</summary>
            <param name="index">Index at which the item will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.Add(`0)">
            <summary>Adds an item to the end of the list</summary>
            <param name="item">Item that will be added to the list</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.Clear">
            <summary>Removes all items from the list</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.Contains(`0)">
            <summary>Checks whether the list contains the specified item</summary>
            <param name="item">Item the list will be checked for</param>
            <returns>True if the list contains the specified items</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the list into an array</summary>
            <param name="array">Array the list will be copied into</param>
            <param name="arrayIndex">
              Index in the target array where the first item will be copied to
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.Remove(`0)">
            <summary>Removes the specified item from the list</summary>
            <param name="item">Item that will be removed from the list</param>
            <returns>
              True if the item was found and removed from the list, false otherwise
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.GetEnumerator">
            <summary>Returns an enumerator for the items in the list</summary>
            <returns>An enumerator for the list's items</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator for the items in the list</summary>
            <returns>An enumerator for the list's items</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the list into an array</summary>
            <param name="array">Array the list will be copied into</param>
            <param name="arrayIndex">
              Index in the target array where the first item will be copied to
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the list</summary>
            <param name="value">Item that will be added to the list</param>
            <returns>
              The position at which the item has been inserted or -1 if the item was not inserted
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.System#Collections#IList#Contains(System.Object)">
            <summary>Checks whether the list contains the specified item</summary>
            <param name="item">Item the list will be checked for</param>
            <returns>True if the list contains the specified items</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>Determines the index of the specified item in the list</summary>
            <param name="item">Item whose index will be determined</param>
            <returns>The index of the item in the list or -1 if not found</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>Inserts an item into the list at the specified index</summary>
            <param name="index">Index the item will be insertted at</param>
            <param name="item">Item that will be inserted into the list</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.System#Collections#IList#Remove(System.Object)">
            <summary>Removes the specified item from the list</summary>
            <param name="item">Item that will be removed from the list</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.OnAdded(`0,System.Int32)">
            <summary>Fires the 'ItemAdded' event</summary>
            <param name="item">Item that has been added to the collection</param>
            <param name="index">Index of the added item</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.OnRemoved(`0,System.Int32)">
            <summary>Fires the 'ItemRemoved' event</summary>
            <param name="item">Item that has been removed from the collection</param>
            <param name="index">Index the item has been removed from</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.OnReplaced(`0,`0,System.Int32)">
            <summary>Fires the 'ItemReplaced' event</summary>
            <param name="oldItem">Item that has been replaced</param>
            <param name="newItem">New item the original item was replaced with</param>
            <param name="index">Index of the replaced item</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.OnClearing">
            <summary>Fires the 'Clearing' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableList`1.OnCleared">
            <summary>Fires the 'Cleared' event</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableList`1.typedList">
            <summary>The wrapped list under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableList`1.objectList">
            <summary>The wrapped list under its object interface</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableList`1.ItemAdded">
            <summary>Raised when an item has been added to the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableList`1.ItemRemoved">
            <summary>Raised when an item is removed from the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableList`1.ItemReplaced">
            <summary>Raised when an item is replaced in the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableList`1.Clearing">
            <summary>Raised when the collection is about to be cleared</summary>
            <remarks>
              This could be covered by calling ItemRemoved for each item currently
              contained in the collection, but it is often simpler and more efficient
              to process the clearing of the entire collection as a special operation.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableList`1.Cleared">
            <summary>Raised when the collection has been cleared</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableList`1.CollectionChanged">
            <summary>Called when the collection has changed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableList`1.Item(System.Int32)">
            <summary>Accesses the item at the specified index in the list</summary>
            <param name="index">Index of the item that will be accessed</param>
            <returns>The item at the specified index</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableList`1.Count">
            <summary>Total number of items in the list</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableList`1.IsReadOnly">
            <summary>Whether the list is a read-only list</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableList`1.System#Collections#ICollection#IsSynchronized">
            <summary>Whether this list performs thread synchronization</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableList`1.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root used by the list to synchronize threads</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableList`1.System#Collections#IList#IsFixedSize">
            <summary>Whether the list is of a fixed size</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableList`1.System#Collections#IList#Item(System.Int32)">
            <summary>Accesses the item at the specified index in the list</summary>
            <param name="index">Index of the item that will be accessed</param>
            <returns>The item at the specified index</returns>
        </member>
        <member name="T:Nuclex.Support.TypeHelperTest">
            <summary>Unit Test for the strign segment class</summary>
        </member>
        <member name="M:Nuclex.Support.TypeHelperTest.CanDetermineIfTypeHasAttribute">
            <summary>
              Verifies that the type helper can determine whether a class is carrying an attribute
            </summary>
        </member>
        <member name="M:Nuclex.Support.TypeHelperTest.CanGetBackingFieldsForPropertiesInBaseClasses">
            <summary>
              Verifies that the GetFieldInfosIncludingBaseClasses() will include the backing
              fields of automatically implemented properties in base classes
            </summary>
        </member>
        <member name="M:Nuclex.Support.TypeHelperTest.AvoidCompilerWarnings">
            <summary>
              Useless test that avoids a compile warning about unused fields
            </summary>
        </member>
        <member name="M:Nuclex.Support.TypeHelperTest.TestDefaultConstructorDetection">
            <summary>Tests whether the default constructor detection works as expected</summary>
        </member>
        <member name="T:Nuclex.Support.TypeHelperTest.NoDefaultConstructor">
            <summary>Test class that doesn't have a default constructor</summary>
        </member>
        <member name="M:Nuclex.Support.TypeHelperTest.NoDefaultConstructor.#ctor(System.Int32)">
            <summary>Initializes a new instance of the test class</summary>
            <param name="dummy">Dummy argument so this is no default constructor</param>
        </member>
        <member name="T:Nuclex.Support.TypeHelperTest.NonPublicDefaultConstructor">
            <summary>Test class that has a non-public default constructor</summary>
        </member>
        <member name="M:Nuclex.Support.TypeHelperTest.NonPublicDefaultConstructor.#ctor">
            <summary>Initializes a new instance of the test class</summary>
        </member>
        <member name="T:Nuclex.Support.TypeHelperTest.PublicDefaultConstructor">
            <summary>Test class that has a public default constructor</summary>
        </member>
        <member name="M:Nuclex.Support.TypeHelperTest.PublicDefaultConstructor.#ctor">
            <summary>Initializes a new instance of the test class</summary>
        </member>
        <member name="T:Nuclex.Support.TypeHelperTest.Base">
            <summary>Base class used to test the helper methods</summary>
        </member>
        <member name="F:Nuclex.Support.TypeHelperTest.Base.PublicBaseField">
            <summary>A simple public field</summary>
        </member>
        <member name="P:Nuclex.Support.TypeHelperTest.Base.PublicBaseProperty">
            <summary>An automatic property with a hidden backing field</summary>
        </member>
        <member name="T:Nuclex.Support.TypeHelperTest.Derived">
            <summary>Derived class used to test the helper methods</summary>
        </member>
        <member name="F:Nuclex.Support.TypeHelperTest.Derived.PublicDerivedField">
            <summary>A simple public field</summary>
        </member>
        <member name="P:Nuclex.Support.TypeHelperTest.Derived.PublicDerivedProperty">
            <summary>An automatic property with a hidden backing field</summary>
        </member>
        <member name="T:Nuclex.Support.TypeHelperTest.HasIgnoreAttribute">
            <summary>Class that carries an IgnoreAttribute</summary>
        </member>
        <member name="T:Nuclex.Support.IO.ChainStreamTest">
            <summary>Unit Test for the stream chainer</summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestPartitionedWrite">
            <summary>
              Tests whether the stream chainer correctly partitions a long write request
              over its chained streams and appends any remaining data to the end of
              the last chained stream.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestPartitionedRead">
            <summary>
              Tests whether the stream chainer correctly partitions a long read request
              over its chained streams.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestWriteAfterResize">
            <summary>
              Tests whether the stream chainer can handle a stream resize
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestWriteToUnseekableStream">
            <summary>
              Tests writing to a stream chainer that contains an unseekable stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestReadFromUnseekableStream">
            <summary>
              Tests reading from a stream chainer that contains an unseekable stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnReadFromUnreadableStream">
            <summary>
              Tests reading from a stream chainer that contains an unreadable stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnWriteToUnwriteableStream">
            <summary>
              Tests writing to a stream chainer that contains an unwriteable stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnLengthChange">
            <summary>
              Verifies that the stream chainer throws an exception if the attempt is
              made to change the length of the stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestCanRead">
            <summary>
              Verifies that the CanRead property is correctly determined by the stream chainer
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestCanWrite">
            <summary>
              Verifies that the CanRead property is correctly determined by the stream chainer
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestCanSeek">
            <summary>
              Verifies that the CanSeek property is correctly determined by the stream chainer
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnSeekWithUnseekableStream">
            <summary>
              Tests whether an exception is thrown if the Seek() method is called on
              a stream chainer with streams that do not support seeking
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnGetPositionWithUnseekableStream">
            <summary>
              Tests whether an exception is thrown if the Position property is retrieved
              on a stream chainer with streams that do not support seeking
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnSetPositionWithUnseekableStream">
            <summary>
              Tests whether an exception is thrown if the Position property is set
              on a stream chainer with streams that do not support seeking
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnGetLengthWithUnseekableStream">
            <summary>
              Tests whether an exception is thrown if the Length property is retrieved
              on a stream chainer with streams that do not support seeking
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestSeeking">
            <summary>
              Tests whether the Seek() method of the stream chainer is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestReadBeyondEndOfStream">
            <summary>
              Tests whether the stream behaves correctly if data is read from beyond its end
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnInvalidSeekReferencePoint">
            <summary>
              Tests whether the Seek() method throws an exception if an invalid
              reference point is provided
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestPositionChange">
            <summary>Verifies that the position property works correctly</summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestFlush">
            <summary>Tests the Flush() method of the stream chainer</summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.chainTwoStreamsOfTenBytes">
            <summary>
              Creates a stream chainer with two streams that each have a size of 10 bytes
            </summary>
            <returns>The new stream chainer with two chained 10-byte streams</returns>
        </member>
        <member name="T:Nuclex.Support.IO.ChainStreamTest.TestStream">
            <summary>Testing stream that allows specific features to be disabled</summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.#ctor(System.IO.Stream,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Initializes a new test stream</summary>
            <param name="wrappedStream">Stream that will be wrapped</param>
            <param name="allowRead">Whether to allow reading from the stream</param>
            <param name="allowWrite">Whether to allow writing to the stream</param>
            <param name="allowSeek">Whether to allow seeking within the stream</param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.Flush">
            <summary>
              Clears all buffers for this stream and causes any buffered data to be written
              to the underlying device.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Reads a sequence of bytes from the stream and advances the position of
              the file pointer by the number of bytes read.
            </summary>
            <param name="buffer">Buffer that will receive the data read from the stream</param>
            <param name="offset">
              Offset in the buffer at which the stream will place the data read
            </param>
            <param name="count">Maximum number of bytes that will be read</param>
            <returns>
              The number of bytes that were actually read from the stream and written into
              the provided buffer
            </returns>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Changes the position of the file pointer</summary>
            <param name="offset">
              Offset to move the file pointer by, relative to the position indicated by
              the <paramref name="origin" /> parameter.
            </param>
            <param name="origin">
              Reference point relative to which the file pointer is placed
            </param>
            <returns>The new absolute position within the stream</returns>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length the stream shall have</param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Writes a sequence of bytes to the stream and advances the position of
              the file pointer by the number of bytes written.
            </summary>
            <param name="buffer">
              Buffer containing the data that will be written to the stream
            </param>
            <param name="offset">
              Offset in the buffer at which the data to be written starts
            </param>
            <param name="count">Number of bytes that will be written into the stream</param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.enforceReadAllowed">
            <summary>Throws an exception if reading is not allowed</summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.enforceWriteAllowed">
            <summary>Throws an exception if writing is not allowed</summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.enforceSeekAllowed">
            <summary>Throws an exception if seeking is not allowed</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStreamTest.TestStream.stream">
            <summary>Stream being wrapped for testing</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStreamTest.TestStream.readAllowed">
            <summary>whether to allow reading from the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStreamTest.TestStream.writeAllowed">
            <summary>Whether to allow writing to the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStreamTest.TestStream.seekAllowed">
            <summary>Whether to allow seeking within the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStreamTest.TestStream.flushCallCount">
            <summary>Number of times the Flush() method has been called</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStreamTest.TestStream.CanRead">
            <summary>Whether data can be read from the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStreamTest.TestStream.CanSeek">
            <summary>Whether the stream supports seeking</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStreamTest.TestStream.CanWrite">
            <summary>Whether data can be written into the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStreamTest.TestStream.Length">
            <summary>Length of the stream in bytes</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStreamTest.TestStream.Position">
            <summary>Absolute position of the file pointer within the stream</summary>
            <exception cref="T:System.NotSupportedException">
              At least one of the chained streams does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStreamTest.TestStream.FlushCallCount">
            <summary>Number of times the Flush() method has been called</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityItemPair`2">
            <summary>An pair of a priority and an item</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPair`2.#ctor(`0,`1)">
            <summary>Initializes a new priority / item pair</summary>
            <param name="priority">Priority of the item in the pair</param>
            <param name="item">Item to be stored in the pair</param>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityItemPair`2.Priority">
            <summary>Priority assigned to this priority / item pair</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityItemPair`2.Item">
            <summary>Item contained in this priority / item pair</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPair`2.ToString">
            <summary>Converts the priority / item pair into a string</summary>
            <returns>A string describing the priority / item pair</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableDictionaryTest">
            <summary>Unit Test for the observable dictionary wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.Setup">
            <summary>Initialization routine executed before each test is run</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestDefaultConstructor">
            <summary>
              Verifies that the default constructor of the observable dictionary works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestCopyConstructor">
            <summary>
              Verifies that the copy constructor of the observable dictionary works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestIsReadOnly">
            <summary>Verifies that the IsReadOnly property is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestContains">
            <summary>
              Checks whether the Contains() method of the observable dictionary is able to
              determine if the dictionary contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestContainsKey">
            <summary>
              Checks whether the Contains() method of the observable dictionary is able to
              determine if the dictionary contains a key
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestCopyToArray">
            <summary>
              Verifies that the CopyTo() of the observable dictionary works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestTypesafeEnumerator">
            <summary>
              Tests whether the typesafe enumerator of the observable dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestGetKeysCollection">
            <summary>
              Tests whether the keys collection of the observable dictionary can be queried
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestGetValuesCollection">
            <summary>
              Tests whether the values collection of the observable dictionary can be queried
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestTryGetValue">
            <summary>
              Tests whether the TryGetValue() method of the observable dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRetrieveValueByIndexer">
            <summary>
              Tests whether the retrieval of values using the indexer of the observable
              dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRetrieveNonExistingValueByIndexer">
            <summary>
              Tests whether an exception is thrown if the indexer of the observable dictionary
              is used to attempt to retrieve a non-existing value
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestAddViaGenericIDictionary">
            <summary>
              Checks whether the Add() methods works via the generic
              IDictionary&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRemoveViaGenericIDictionary">
            <summary>
              Checks whether the Remove() method works via the generic
              IDictionary&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRetrieveValueByIndexerViaGenericIDictionary">
            <summary>
              Tests whether the TryGetValue() method of the observable dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestReplaceByIndexerViaGenericIDictionary">
            <summary>
              Verifies that the indexer can be used to insert an item via the generic
              IDictionar&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestClearViaIDictionary">
            <summary>
              Checks whether the Clear() method of observable dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestAddViaIDictionary">
            <summary>
              Checks whether the Add() method works via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestContainsViaIDictionary">
            <summary>
              Checks whether the Contains() method of the observable dictionary is able to
              determine if the dictionary contains an item via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestEnumeratorViaIDictionary">
            <summary>
              Checks whether the GetEnumerator() method of the observable dictionary
              returns a working enumerator if accessed via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestIsFixedSizeViaIList">
            <summary>
              Checks whether the IsFixedSize property of the observable dictionary returns
              the expected result for a read only dictionary based on a dynamic dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestGetKeysCollectionViaIDictionary">
            <summary>
              Tests whether the keys collection of the observable dictionary can be queried
              via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestGetValuesCollectionViaIDictionary">
            <summary>
              Tests whether the values collection of the observable dictionary can be queried
              via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRemoveViaIDictionary">
            <summary>
              Checks whether Remove() method works via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRetrieveValueByIndexerViaIDictionary">
            <summary>
              Tests whether the retrieval of values using the indexer of the observable
              dictionary is working via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestReplaceByIndexerViaIDictionary">
            <summary>
              Verifies the indexer can be used to insert an item via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestAddViaGenericICollection">
            <summary>
              Checks whether Add() method is working via the generic
              ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestClearViaGenericICollection">
            <summary>
              Checks whether the Clear() method is working via the generic
              ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRemoveViaGenericICollection">
            <summary>
              Checks whether the Remove() method is working via the
              generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestCopyToArrayViaICollection">
            <summary>
              Verifies that the CopyTo() of the observable dictionary works when called
              via the the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestSerialization">
            <summary>
              Test whether the observable dictionary can be serialized
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.createTestDictionary">
            <summary>
              Creates a new observable dictionary filled with some values for testing
            </summary>
            <returns>The newly created observable dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.makeObservable(System.Collections.Generic.IDictionary{System.Int32,System.String})">
            <summary>
              Creates a new observable dictionary filled with some values for testing
            </summary>
            <returns>The newly created observable dictionary</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableDictionaryTest.mockery">
            <summary>Mock object factory</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableDictionaryTest.mockedSubscriber">
            <summary>The mocked observable collection subscriber</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableDictionaryTest.observedDictionary">
            <summary>An observable dictionary to which a mock will be subscribed</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableDictionaryTest.IObservableDictionarySubscriber">
            <summary>Interface used to test the observable dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.IObservableDictionarySubscriber.Clearing(System.Object,System.EventArgs)">
            <summary>Called when the dictionary is about to clear its contents</summary>
            <param name="sender">Dictionary that is clearing its contents</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.IObservableDictionarySubscriber.Cleared(System.Object,System.EventArgs)">
            <summary>Called when the dictionary has been clear of its contents</summary>
            <param name="sender">Dictionary that was cleared of its contents</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.IObservableDictionarySubscriber.ItemAdded(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.Collections.Generic.KeyValuePair{System.Int32,System.String}})">
            <summary>Called when an item is added to the dictionary</summary>
            <param name="sender">Dictionary to which an item is being added</param>
            <param name="arguments">Contains the item that is being added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.IObservableDictionarySubscriber.ItemRemoved(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.Collections.Generic.KeyValuePair{System.Int32,System.String}})">
            <summary>Called when an item is removed from the dictionary</summary>
            <param name="sender">Dictionary from which an item is being removed</param>
            <param name="arguments">Contains the item that is being removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.IObservableDictionarySubscriber.ItemReplaced(System.Object,Nuclex.Support.Collections.ItemReplaceEventArgs{System.Collections.Generic.KeyValuePair{System.Int32,System.String}})">
            <summary>Called when an item is replaced in the dictionary</summary>
            <param name="sender">Dictionary in which an item is being replaced</param>
            <param name="arguments">Contains the replaced item and its replacement</param>
        </member>
        <member name="T:Nuclex.Support.Collections.ItemEventArgsTest">
            <summary>Unit Test for the item event argument container</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ItemEventArgsTest.IntegersCanBeCarried">
            <summary>
              Tests whether an integer argument can be stored in the argument container
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ItemEventArgsTest.StringsCanBeCarried">
            <summary>
              Tests whether a string argument can be stored in the argument container
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.Constants">
            <summary>Contains fixed constants used by some collections</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Constants.NotifyCollectionResetEventArgs">
            <summary>Fixed event args used to notify that the collection has reset</summary>
        </member>
        <member name="T:Nuclex.Support.Cloning.ExpressionTreeClonerTest">
            <summary>Unit Test for the expression tree-based cloner</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.#ctor">
            <summary>Initializes a new unit test suite for the reflection cloner</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.CloningNullYieldsNull">
            <summary>Verifies that cloning a null object simply returns null</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.ClassWithoutDefaultConstructorCanBeCloned">
            <summary>
              Verifies that clones of objects whose class doesn't possess a default constructor
              can be made
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.PrimitiveTypesCanBeCloned">
            <summary>Verifies that clones of primitive types can be created</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.ReferenceTypesCanBeCloned">
            <summary>Verifies that shallow clones of arrays can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.PrimitiveArraysCanBeCloned">
            <summary>Verifies that shallow clones of arrays can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.ShallowClonesOfArraysCanBeMade">
            <summary>Verifies that shallow clones of arrays can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.DeepClonesOfArraysCanBeMade">
            <summary>Verifies that deep clones of arrays can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.GenericListsCanBeCloned">
            <summary>Verifies that deep clones of a generic list can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.GenericDictionariesCanBeCloned">
            <summary>Verifies that deep clones of a generic dictionary can be made</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.ShallowFieldBasedClonesOfValueTypesCanBeMade">
            <summary>
              Verifies that a field-based shallow clone of a value type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.ShallowFieldBasedClonesOfReferenceTypesCanBeMade">
            <summary>
              Verifies that a field-based shallow clone of a reference type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.DeepFieldBasedClonesOfValueTypesCanBeMade">
            <summary>
              Verifies that a field-based deep clone of a value type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.DeepFieldBasedClonesOfReferenceTypesCanBeMade">
            <summary>
              Verifies that a field-based deep clone of a reference type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.ShallowPropertyBasedClonesOfValueTypesCanBeMade">
            <summary>
              Verifies that a property-based shallow clone of a value type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.ShallowPropertyBasedClonesOfReferenceTypesCanBeMade">
            <summary>
              Verifies that a property-based shallow clone of a reference type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.DeepPropertyBasedClonesOfValueTypesCanBeMade">
            <summary>
              Verifies that a property-based deep clone of a value type can be performed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.ExpressionTreeClonerTest.DeepPropertyBasedClonesOfReferenceTypesCanBeMade">
            <summary>
              Verifies that a property-based deep clone of a reference type can be performed
            </summary>
        </member>
        <member name="F:Nuclex.Support.Cloning.ExpressionTreeClonerTest.cloneFactory">
            <summary>Clone factory being tested</summary>
        </member>
        <member name="T:Nuclex.Support.StringBuilderHelper">
            <summary>Contains helper methods for the string builder class</summary>
        </member>
        <member name="F:Nuclex.Support.StringBuilderHelper.numbers">
            <summary>Predefined unicode characters for the numbers 0 to 9</summary>
        </member>
        <member name="F:Nuclex.Support.StringBuilderHelper.decimalSeparator">
            <summary>Characters used to separate decimal places in a number</summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Clear(System.Text.StringBuilder)">
            <summary>Clears the contents of a string builder</summary>
            <param name="builder">String builder that will be cleared</param>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Byte,Nuclex.Support.GarbagePolicy)">
            <summary>
              Appends an integer to a string builder without generating garbage
            </summary>
            <param name="builder">String builder to which an integer will be appended</param>
            <param name="value">Byte that will be appended to the string builder</param>
            <param name="garbagePolicy">How to behave regarding the garbage collector</param>
            <remarks>
              The normal StringBuilder.Append() method generates garbage when converting
              integer arguments whereas this method will avoid any garbage, albeit probably
              with a small performance impact compared to the built-in method.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Int32,Nuclex.Support.GarbagePolicy)">
            <summary>
              Appends an integer to a string builder without generating garbage
            </summary>
            <param name="builder">String builder to which an integer will be appended</param>
            <param name="value">Integer that will be appended to the string builder</param>
            <param name="garbagePolicy">How to behave regarding the garbage collector</param>
            <remarks>
              The normal StringBuilder.Append() method generates garbage when converting
              integer arguments whereas this method will avoid any garbage, albeit probably
              with a small performance impact compared to the built-in method.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Int64,Nuclex.Support.GarbagePolicy)">
            <summary>
              Appends an long integer to a string builder without generating garbage
            </summary>
            <param name="builder">String builder to which an integer will be appended</param>
            <param name="value">Long integer that will be appended to the string builder</param>
            <param name="garbagePolicy">How to behave regarding the garbage collector</param>
            <remarks>
              The normal StringBuilder.Append() method generates garbage when converting
              integer arguments whereas this method will avoid any garbage, albeit probably
              with a small performance impact compared to the built-in method.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Single,Nuclex.Support.GarbagePolicy)">
            <summary>
              Appends a floating point value to a string builder without generating garbage
            </summary>
            <param name="builder">String builder the value will be appended to</param>
            <param name="value">Value that will be appended to the string builder</param>
            <param name="garbagePolicy">How to behave regarding the garbage collector</param>
            <returns>Whether the value was inside the algorithm's supported range</returns>
            <remarks>
              Uses an algorithm that covers the sane range of possible values but will
              fail to render extreme values, NaNs and infinity. In these cases, false
              is returned and the traditional double.ToString() method can be used.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Single,System.Int32)">
            <summary>
              Appends a floating point value to a string builder without generating garbage
            </summary>
            <param name="builder">String builder the value will be appended to</param>
            <param name="value">Value that will be appended to the string builder</param>
            <param name="decimalPlaces">Maximum number of decimal places to display</param>
            <returns>Whether the value was inside the algorithm's supported range</returns>
            <remarks>
              Uses an algorithm that covers the sane range of possible values but will
              fail to render extreme values, NaNs and infinity. In these cases, false
              is returned and the traditional double.ToString() method can be used.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Double,Nuclex.Support.GarbagePolicy)">
            <summary>
              Appends a double precision floating point value to a string builder
              without generating garbage
            </summary>
            <param name="builder">String builder the value will be appended to</param>
            <param name="value">Value that will be appended to the string builder</param>
            <param name="garbagePolicy">How to behave regarding the garbage collector</param>
            <returns>Whether the value was inside the algorithm's supported range</returns>
            <remarks>
              Uses an algorithm that covers the sane range of possible values but will
              fail to render extreme values, NaNs and infinity. In these cases, false
              is returned and the traditional double.ToString() method can be used.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Double,System.Int32)">
            <summary>
              Appends a double precision floating point value to a string builder
              without generating garbage
            </summary>
            <param name="builder">String builder the value will be appended to</param>
            <param name="value">Value that will be appended to the string builder</param>
            <param name="decimalPlaces">Maximum number of decimal places to display</param>
            <returns>Whether the value was inside the algorithm's supported range</returns>
            <remarks>
              Uses an algorithm that covers the sane range of possible values but will
              fail to render extreme values, NaNs and infinity. In these cases, false
              is returned and the traditional double.ToString() method can be used.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.recursiveAppend(System.Text.StringBuilder,System.Int32)">
            <summary>Recursively appends a number's characters to a string builder</summary>
            <param name="builder">String builder the number will be appended to</param>
            <param name="remaining">Remaining digits that will be recursively processed</param>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.recursiveAppend(System.Text.StringBuilder,System.Int64)">
            <summary>Recursively appends a number's characters to a string builder</summary>
            <param name="builder">String builder the number will be appended to</param>
            <param name="remaining">Remaining digits that will be recursively processed</param>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.getDecimalSeparator">
            <summary>Looks up the decimal separator used by the current system</summary>
            <returns></returns>
        </member>
        <member name="T:Nuclex.Support.IO.PartialStream">
            <summary>Wraps a stream and exposes only a limited region of its data</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.#ctor(System.IO.Stream,System.Int64,System.Int64)">
            <summary>Initializes a new partial stream</summary>
            <param name="stream">
              Stream the wrapper will make a limited region accessible of
            </param>
            <param name="start">
              Start index in the stream which becomes the beginning for the wrapper
            </param>
            <param name="length">
              Length the wrapped stream should report and allow access to
            </param>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.Flush">
            <summary>
              Clears all buffers for this stream and causes any buffered data to be written
              to the underlying device.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Reads a sequence of bytes from the stream and advances the position of
              the file pointer by the number of bytes read.
            </summary>
            <param name="buffer">Buffer that will receive the data read from the stream</param>
            <param name="offset">
              Offset in the buffer at which the stream will place the data read
            </param>
            <param name="count">Maximum number of bytes that will be read</param>
            <returns>
              The number of bytes that were actually read from the stream and written into
              the provided buffer
            </returns>
            <exception cref="T:System.NotSupportedException">
              The wrapped stream does not support reading
            </exception>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Changes the position of the file pointer</summary>
            <param name="offset">
              Offset to move the file pointer by, relative to the position indicated by
              the <paramref name="origin" /> parameter.
            </param>
            <param name="origin">
              Reference point relative to which the file pointer is placed
            </param>
            <returns>The new absolute position within the stream</returns>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length the stream shall have</param>
            <exception cref="T:System.NotSupportedException">
              Always, the stream chainer does not support the SetLength() operation
            </exception>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Writes a sequence of bytes to the stream and advances the position of
              the file pointer by the number of bytes written.
            </summary>
            <param name="buffer">
              Buffer containing the data that will be written to the stream
            </param>
            <param name="offset">
              Offset in the buffer at which the data to be written starts
            </param>
            <param name="count">Number of bytes that will be written into the stream</param>
            <remarks>
              The behavior of this method is as follows: If one or more chained streams
              do not support seeking, all data is appended to the final stream in the
              chain. Otherwise, writing will begin with the stream the current file pointer
              offset falls into. If the end of that stream is reached, writing continues
              in the next stream. On the last stream, writing more data into the stream
              that it current size allows will enlarge the stream.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.moveFilePointer(System.Int64)">
            <summary>Moves the file pointer</summary>
            <param name="position">New position the file pointer will be moved to</param>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.makeSeekNotSupportedException(System.String)">
            <summary>
              Constructs a NotSupportException for an error caused by the wrapped
              stream having no seek support
            </summary>
            <param name="action">Action that was tried to perform</param>
            <returns>The newly constructed NotSupportedException</returns>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStream.stream">
            <summary>Streams that have been chained together</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStream.start">
            <summary>Start index of the partial stream in the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStream.position">
            <summary>Zero-based position of the partial stream's file pointer</summary>
            <remarks>
              If the stream does not support seeking, the position will simply be counted
              up until it reaches <see cref="F:Nuclex.Support.IO.PartialStream.length"/>.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStream.length">
            <summary>Length of the partial stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.CanRead">
            <summary>Whether data can be read from the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.CanSeek">
            <summary>Whether the stream supports seeking</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.CanWrite">
            <summary>Whether data can be written into the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.Length">
            <summary>Length of the stream in bytes</summary>
            <exception cref="T:System.NotSupportedException">
              The wrapped stream does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.Position">
            <summary>Absolute position of the file pointer within the stream</summary>
            <exception cref="T:System.NotSupportedException">
              The wrapped stream does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.CompleteStream">
            <summary>Stream being wrapped by the partial stream wrapper</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyDictionaryTest">
            <summary>Unit Test for the read only dictionary wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestCopyConstructor">
            <summary>
              Verifies that the copy constructor of the read only dictionary works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestIsReadOnly">
            <summary>Verifies that the IsReadOnly property returns true</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestContains">
            <summary>
              Checks whether the Contains() method of the read only dictionary is able to
              determine if the dictionary contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestContainsKey">
            <summary>
              Checks whether the Contains() method of the read only dictionary is able to
              determine if the dictionary contains a key
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestCopyToArray">
            <summary>
              Verifies that the CopyTo() of the read only dictionary works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestTypesafeEnumerator">
            <summary>
              Tests whether the typesafe enumerator of the read only dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestGetKeysCollection">
            <summary>
              Tests whether the keys collection of the read only dictionary can be queried
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestGetValuesCollection">
            <summary>
              Tests whether the values collection of the read only dictionary can be queried
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestTryGetValue">
            <summary>
              Tests whether the TryGetValue() method of the read only dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestRetrieveValueByIndexer">
            <summary>
              Tests whether the retrieval of values using the indexer of the read only
              dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnRetrieveNonExistingValueByIndexer">
            <summary>
              Tests whether an exception is thrown if the indexer of the read only dictionary
              is used to attempt to retrieve a non-existing value
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnAddViaGenericIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Add() method is called via the generic IDictionary&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnRemoveViaGenericIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Remove() method is called via the generic IDictionary&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestRetrieveValueByIndexerViaGenericIDictionary">
            <summary>
              Tests whether the TryGetValue() method of the read only dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnReplaceByIndexerViaGenericIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              indexer is used to insert an item via the generic IDictionar&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnClearViaIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Clear() method is called via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnAddViaIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Add() method is called via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestContainsViaIDictionary">
            <summary>
              Checks whether the Contains() method of the read only dictionary is able to
              determine if the dictionary contains an item via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestEnumeratorViaIDictionary">
            <summary>
              Checks whether the GetEnumerator() method of the read only dictionary returns
              a working enumerator if accessed via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestIsFixedSizeViaIList">
            <summary>
              Checks whether the IsFixedSize property of the read only dictionary returns
              the expected result for a read only dictionary based on a dynamic dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestGetKeysCollectionViaIDictionary">
            <summary>
              Tests whether the keys collection of the read only dictionary can be queried
              via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestGetValuesCollectionViaIDictionary">
            <summary>
              Tests whether the values collection of the read only dictionary can be queried
              via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnRemoveViaIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Remove() method is called via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestRetrieveValueByIndexerViaIDictionary">
            <summary>
              Tests whether the retrieval of values using the indexer of the read only
              dictionary is working via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnReplaceByIndexerViaIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              indexer is used to insert an item via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnAddViaGenericICollection">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Add() method is used via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnClearViaGenericICollection">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Clear() method is used via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnRemoveViaGenericICollection">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Remove() method is used via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestCopyToArrayViaICollection">
            <summary>
              Verifies that the CopyTo() of the read only dictionary works when called
              via the the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestSerialization">
            <summary>
              Test whether the read only dictionary can be serialized
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.createTestDictionary">
            <summary>
              Creates a new read-only dictionary filled with some values for testing
            </summary>
            <returns>The newly created read-only dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.makeReadOnly(System.Collections.Generic.IDictionary{System.Int32,System.String})">
            <summary>
              Creates a new read-only dictionary filled with some values for testing
            </summary>
            <returns>The newly created read-only dictionary</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.Pool`1">
            <summary>Pool that recycles objects in order to avoid garbage build-up</summary>
            <typeparam name="TItem">Type of objects being pooled</typeparam>
            <remarks>
              <para>
                Use this class to recycle objects instead of letting them become garbage,
                creating new instances each time. The Pool class is designed to either be
                used on its own or as a building block for a static class that wraps it.
              </para>
              <para>
                Special care has to be taken to revert the entire state of a recycled
                object when it is returned to the pool. For example, events will need to
                have their subscriber lists emptied to avoid sending out events to the
                wrong subscribers and accumulating more and more subscribers each time
                they are reused.
              </para>
              <para>
                To simplify such cleanup, pooled objects can implement the IRecyclable
                interface. When an object is returned to the pool, the pool will
                automatically call its IRecyclable.Recycle() method.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Collections.Pool`1.DefaultPoolSize">
            <summary>Default number of recyclable objects the pool will store</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.#ctor">
            <summary>Initializes a new pool using the default capacity</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.#ctor(System.Func{`0})">
            <summary>Initializes a new pool using the default capacity</summary>
            <param name="createNewDelegate">Delegate that will be used to create new items</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.#ctor(System.Func{`0},System.Action{`0})">
            <summary>Initializes a new pool using the default capacity</summary>
            <param name="createNewDelegate">Delegate that will be used to create new items</param>
            <param name="recycleDelegate">Delegate that will be used to recycle items</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.#ctor(System.Int32)">
            <summary>Initializes a new pool using a user-specified capacity</summary>
            <param name="capacity">Capacity of the pool</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.#ctor(System.Int32,System.Func{`0})">
            <summary>Initializes a new pool using a user-specified capacity</summary>
            <param name="capacity">Capacity of the pool</param>
            <param name="createNewDelegate">Delegate that will be used to create new items</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.#ctor(System.Int32,System.Func{`0},System.Action{`0})">
            <summary>Initializes a new pool using a user-specified capacity</summary>
            <param name="capacity">Capacity of the pool</param>
            <param name="createNewDelegate">Delegate that will be used to create new items</param>
            <param name="recycleDelegate">Delegate that will be used to recycle items</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.Get">
            <summary>
              Returns a new or recycled instance of the types managed by the pool
            </summary>
            <returns>A new or recycled instance</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.Redeem(`0)">
            <summary>
              Redeems an instance that is no longer used to be recycled by the pool
            </summary>
            <param name="item">The instance that will be redeemed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.callRecycleIfSupported(`0)">
            <summary>
              Calls the Recycle() method on an objects if it implements
              the IRecyclable interface
            </summary>
            <param name="item">
              Object whose Recycle() method will be called if supported by the object
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.Pool`1.items">
            <summary>Objects being retained for recycling</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Pool`1.capacity">
            <summary>Capacity of the pool</summary>
            <remarks>
              Required because the Queue class doesn't allow this value to be retrieved
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Collections.Pool`1.createNewDelegate">
            <summary>Delegate used to create new instances of the pool's type</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Pool`1.recycleDelegate">
            <summary>Delegate used to recycle instances</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Pool`1.Capacity">
            <summary>Number of objects the pool can retain</summary>
            <remarks>
              Changing this value causes the pool to be emtpied. It is recommended that
              you only read the pool's capacity, never change it.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableDictionary`2">
            <summary>A dictionary that sneds out change notifications</summary>
            <typeparam name="TKey">Type of the keys used in the dictionary</typeparam>
            <typeparam name="TValue">Type of the values used in the dictionary</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.#ctor">
            <summary>Initializes a new observable dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>Initializes a new observable Dictionary wrapper</summary>
            <param name="dictionary">Dictionary that will be wrapped</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the System.WeakReference class, using deserialized
              data from the specified serialization and stream objects.
            </summary>
            <param name="info">
              An object that holds all the data needed to serialize or deserialize the
              current System.WeakReference object.
            </param>
            <param name="context">
              (Reserved) Describes the source and destination of the serialized stream
              specified by info.
            </param>
            <exception cref="T:System.ArgumentNullException">
              The info parameter is null.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
              Determines whether the specified KeyValuePair is contained in the Dictionary
            </summary>
            <param name="item">KeyValuePair that will be checked for</param>
            <returns>True if the provided KeyValuePair was contained in the Dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the Dictionary contains the specified key</summary>
            <param name="key">Key that will be checked for</param>
            <returns>
              True if an entry with the specified key was contained in the Dictionary
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.GetEnumerator">
            <summary>Creates a new enumerator for the Dictionary</summary>
            <returns>The new Dictionary enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.TryGetValue(`0,`1@)">
            <summary>
              Attempts to retrieve the item with the specified key from the Dictionary
            </summary>
            <param name="key">Key of the item to attempt to retrieve</param>
            <param name="value">
              Output parameter that will receive the key upon successful completion
            </param>
            <returns>
              True if the item was found and has been placed in the output parameter
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.Add(`0,`1)">
            <summary>Inserts an item into the Dictionary</summary>
            <param name="key">Key under which to add the new item</param>
            <param name="value">Item that will be added to the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.Remove(`0)">
            <summary>Removes the item with the specified key from the Dictionary</summary>
            <param name="key">Key of the elementes that will be removed</param>
            <returns>True if an item with the specified key was found and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnAdded(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Fires the 'ItemAdded' event</summary>
            <param name="item">Item that has been added to the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnRemoved(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Fires the 'ItemRemoved' event</summary>
            <param name="item">Item that has been removed from the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnReplaced(System.Collections.Generic.KeyValuePair{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Fires the 'ItemReplaced' event</summary>
            <param name="oldItem">Item that has been replaced in the collection</param>
            <param name="newItem">Item with which the original item was replaced</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnClearing">
            <summary>Fires the 'Clearing' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnCleared">
            <summary>Fires the 'Cleared' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new object enumerator for the Dictionary</summary>
            <returns>The new object enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>Adds an item into the Dictionary</summary>
            <param name="key">Key under which the item will be added</param>
            <param name="value">Item that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>Determines whether the specified key exists in the Dictionary</summary>
            <param name="key">Key that will be checked for</param>
            <returns>True if an item with the specified key exists in the Dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>Removes an item from the Dictionary</summary>
            <param name="key">Key of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>Returns a new entry enumerator for the dictionary</summary>
            <returns>The new entry enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Inserts an already prepared element into the Dictionary</summary>
            <param name="item">Prepared element that will be added to the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Removes all items from the Dictionary</summary>
            <param name="itemToRemove">Item that will be removed from the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary contents will be copied into</param>
            <param name="index">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Serializes the Dictionary</summary>
            <param name="info">
              Provides the container into which the Dictionary will serialize itself
            </param>
            <param name="context">
              Contextual informations about the serialization environment
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)">
            <summary>Called after all objects have been successfully deserialized</summary>
            <param name="sender">Nicht unterstützt</param>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableDictionary`2.typedDictionary">
            <summary>The wrapped Dictionary under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableDictionary`2.objectDictionary">
            <summary>The wrapped Dictionary under its object interface</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.ItemAdded">
            <summary>Raised when an item has been added to the dictionary</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.ItemRemoved">
            <summary>Raised when an item is removed from the dictionary</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.ItemReplaced">
            <summary>Raised when an item is replaced in the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.Clearing">
            <summary>Raised when the dictionary is about to be cleared</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.Cleared">
            <summary>Raised when the dictionary has been cleared</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.CollectionChanged">
            <summary>Called when the collection has changed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.IsReadOnly">
            <summary>Whether the directory is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.Count">
            <summary>Number of elements contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.Keys">
            <summary>Collection of all keys contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.Values">
            <summary>Collection of all values contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.Item(`0)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>Whether the size of the Dictionary is fixed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Keys">
            <summary>Returns a collection of all keys in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Values">
            <summary>Returns a collection of all values stored in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
            <returns>The item with the specified key</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the Dictionary is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the Dictionary locks</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableDictionary`2.SerializedDictionary">
            <summary>
              Dictionary wrapped used to reconstruct a serialized read only dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.SerializedDictionary.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the System.WeakReference class, using deserialized
              data from the specified serialization and stream objects.
            </summary>
            <param name="info">
              An object that holds all the data needed to serialize or deserialize the
              current System.WeakReference object.
            </param>
            <param name="context">
              (Reserved) Describes the source and destination of the serialized stream
              specified by info.
            </param>
            <exception cref="T:System.ArgumentNullException">
              The info parameter is null.
            </exception>
        </member>
        <member name="T:Nuclex.Support.Cloning.IStateCopier">
            <summary>Copies the state of objects</summary>
        </member>
        <member name="M:Nuclex.Support.Cloning.IStateCopier.DeepCopyState``1(``0,``0,System.Boolean)">
            <summary>
              Transfers the state of one object into another, creating clones of referenced objects
            </summary>
            <typeparam name="TState">Type of the object whose sate will be transferred</typeparam>
            <param name="original">Original instance the state will be taken from</param>
            <param name="target">Target instance the state will be written to</param>
            <param name="propertyBased">Whether to perform a property-based state copy</param>
            <remarks>
              A property-based copy is useful if you're using dynamically generated proxies,
              such as when working with entities returned by an ORM like NHibernate.
              When not using a property-based copy, internal proxy fields would be copied
              and might cause problems with the ORM.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Cloning.IStateCopier.DeepCopyState``1(``0@,``0@,System.Boolean)">
            <summary>
              Transfers the state of one object into another, creating clones of referenced objects
            </summary>
            <typeparam name="TState">Type of the object whose sate will be transferred</typeparam>
            <param name="original">Original instance the state will be taken from</param>
            <param name="target">Target instance the state will be written to</param>
            <param name="propertyBased">Whether to perform a property-based state copy</param>
            <remarks>
              A property-based copy is useful if you're using dynamically generated proxies,
              such as when working with entities returned by an ORM like NHibernate.
              When not using a property-based copy, internal proxy fields would be copied
              and might cause problems with the ORM.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Cloning.IStateCopier.ShallowCopyState``1(``0,``0,System.Boolean)">
            <summary>Transfers the state of one object into another</summary>
            <typeparam name="TState">Type of the object whose sate will be transferred</typeparam>
            <param name="original">Original instance the state will be taken from</param>
            <param name="target">Target instance the state will be written to</param>
            <param name="propertyBased">Whether to perform a property-based state copy</param>
            <remarks>
              A property-based copy is useful if you're using dynamically generated proxies,
              such as when working with entities returned by an ORM like NHibernate.
              When not using a property-based copy, internal proxy fields would be copied
              and might cause problems with the ORM.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Cloning.IStateCopier.ShallowCopyState``1(``0@,``0@,System.Boolean)">
            <summary>Transfers the state of one object into another</summary>
            <typeparam name="TState">Type of the object whose sate will be transferred</typeparam>
            <param name="original">Original instance the state will be taken from</param>
            <param name="target">Target instance the state will be written to</param>
            <param name="propertyBased">Whether to perform a property-based state copy</param>
            <remarks>
              A property-based copy is useful if you're using dynamically generated proxies,
              such as when working with entities returned by an ORM like NHibernate.
              When not using a property-based copy, internal proxy fields would be copied
              and might cause problems with the ORM.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Semaphore">
            <summary>A reverse counting semaphore</summary>
            <remarks>
              <para>
                This semaphore counts in reverse, which means you can Release() the semaphore
                as often as you'd like a thread calling WaitOne() to be let through. You
                can use it in the traditional sense and have any Thread calling WaitOne()
                make sure to call Release() afterwards, or you can, for example, Release() it
                whenever work becomes available and let threads take work from the Semaphore
                by calling WaitOne() alone.
              </para>
              <para>
                Implementation notes (ignore this if you just want to use the Semaphore)
              </para>
              <para>
                We could design a semaphore that uses an auto reset event, where the thread
                that gets to pass immediately sets the event again if the semaphore isn't full
                yet to let another thread pass.
              </para>
              <para>
                However, this would mean that when a semaphore receives a large number of
                wait requests, assuming it would allow, for example, 25 users at once, the
                thread scheduler would see only 1 thread become eligible for execution. Then
                that thread would unlock the next and so on. In short, we wait 25 times
                for the thread scheduler to wake up a thread until all users get through.
              </para>
              <para>
                So we chose a ManualResetEvent, which will wake up more threads than
                neccessary and possibly cause a period of intense competition for getting
                a lock on the resource, but will make the thread scheduler see all threads
                become eligible for execution.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Semaphore.#ctor">
            <summary>Initializes a new semaphore</summary>
        </member>
        <member name="M:Nuclex.Support.Semaphore.#ctor(System.Int32)">
            <summary>Initializes a new semaphore</summary>
            <param name="count">
              Number of users that can access the resource at the same time
            </param>
        </member>
        <member name="M:Nuclex.Support.Semaphore.#ctor(System.Int32,System.Int32)">
            <summary>Initializes a new semaphore</summary>
            <param name="initialCount">
              Initial number of users accessing the resource 
            </param>
            <param name="maximumCount">
              Maximum numbr of users that can access the resource at the same time
            </param>
        </member>
        <member name="M:Nuclex.Support.Semaphore.Dispose(System.Boolean)">
            <summary>Immediately releases all resources owned by the instance</summary>
            <param name="explicitDisposing">
              Whether Dispose() has been called explictly
            </param>
        </member>
        <member name="M:Nuclex.Support.Semaphore.WaitOne(System.Int32,System.Boolean)">
            <summary>
              Waits for the resource to become available and locks it
            </summary>
            <param name="millisecondsTimeout">
              Number of milliseconds to wait at most before giving up
            </param>
            <param name="exitContext">
              True to exit the synchronization domain for the context before the wait (if
              in a synchronized context), and reacquire it afterward; otherwise, false.
            </param>
            <returns>
              True if the resource was available and is now locked, false if
              the timeout has been reached.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Semaphore.WaitOne">
            <summary>
              Waits for the resource to become available and locks it
            </summary>
            <returns>
              True if the resource was available and is now locked, false if
              the timeout has been reached.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Semaphore.WaitOne(System.TimeSpan,System.Boolean)">
            <summary>
              Waits for the resource to become available and locks it
            </summary>
            <param name="timeout">
              Time span to wait for the lock before giving up
            </param>
            <param name="exitContext">
              True to exit the synchronization domain for the context before the wait (if
              in a synchronized context), and reacquire it afterward; otherwise, false.
            </param>
            <returns>
              True if the resource was available and is now locked, false if
              the timeout has been reached.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Semaphore.Release">
            <summary>
              Releases a lock on the resource. Note that for a reverse counting semaphore,
              it is legal to Release() the resource before locking it.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Semaphore.createEvent">
            <summary>Creates the event used to make threads wait for the resource</summary>
        </member>
        <member name="F:Nuclex.Support.Semaphore.manualResetEvent">
            <summary>Event used to make threads wait if the semaphore is full</summary>
        </member>
        <member name="F:Nuclex.Support.Semaphore.free">
            <summary>Number of users currently accessing the resource</summary>
            <remarks>
              Since this is a reverse counting semaphore, it will be negative if
              the resource is available and 0 if the semaphore is full.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.XmlHelperTest">
            <summary>Unit Test for the XML helper class</summary>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.brokenSchemaXml">
            <summary>A broken XML schema</summary>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.syntaxErrorSchemaXml">
            <summary>An XML schema with a syntax error</summary>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.pointsSchemaXml">
            <summary>A valid XML schema for a list of 2D points</summary>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.brokenXml">
            <summary>A broken XML document</summary>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.unconformantXml">
            <summary>
              Well-formed XML document that is not conformant to the schema above
            </summary>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.conformantXml">
            <summary>Well-formed XML document that is conformant to the schema</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestThrowOnInvalidSchema">
            <summary>
              Verifies that an exception is thrown when a schema fails to load
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestThrowOnSyntaxErrorSchema">
            <summary>
              Verifies that an exception is thrown when a schema contains a syntax error
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestFailOnTryLoadNonExistingFile">
            <summary>
              Verfifies that TryLoadSchema() can fail without throwing an exception
              when the schema is not a valid XML document
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestFailOnTryLoadBrokenSchema">
            <summary>
              Verfifies that TryLoadSchema() can fail without throwing an exception
              when the schema is not a valid XML document
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestFailOnTryLoadSyntaxErrorSchema">
            <summary>
              Verfifies that TryLoadSchema() can fail without throwing an exception
              when the schema contains a syntax error
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestLoadSchema">
            <summary>Tests whether a normal, valid schema can be loaded successfully</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestTryLoadSchema">
            <summary>Tests whether a normal, valid schema can be loaded successfully</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestFailOnLoadInvalidDocument">
            <summary>
              Verifies that an exception is thrown when an invalid XML document is loaded
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestFailOnLoadNonConformingDocument">
            <summary>
              Verifies that an exception is thrown when a nonconformant XML document is loaded
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestLoadConformingDocument">
            <summary>
              Tests whether a normal, conformant XML document can be loaded successfully
            </summary>
        </member>
        <member name="T:Nuclex.Support.XmlHelperTest.TempFileKeeper">
            <summary>
              Creates a temporary file and automatically deletes it on dispose
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TempFileKeeper.#ctor(System.String)">
            <summary>
              Creates a temporary file with the specified contents using the UTF8 encoding
            </summary>
            <param name="fileContents">
              Contents that will be written into the temporary file
            </param>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TempFileKeeper.#ctor(System.String,System.Text.Encoding)">
            <summary>Creates a temporary file with the specified contents</summary>
            <param name="fileContents">
              Contents that will be written into the temporary file
            </param>
            <param name="encoding">
              Encoding to use for writing the contents into the file
            </param>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TempFileKeeper.Finalize">
            <summary>Called when the instance is collected by the GC</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TempFileKeeper.Dispose">
            <summary>Immediately releases all resources used by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TempFileKeeper.op_Implicit(Nuclex.Support.XmlHelperTest.TempFileKeeper)~System.String">
            <summary>Implicitely converts a TempFileKeeper into a file path</summary>
            <param name="tempFileKeeper">TempFileKeeper that will be converted</param>
            <returns>The path to the temporary file managed by the TempFileKeeper</returns>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.TempFileKeeper.tempFilePath">
            <summary>Path to the temporary file the TempFileKeeper is managing</summary>
        </member>
        <member name="T:Nuclex.Support.WeakReferenceTest">
            <summary>Unit Test for the strongly typed weak reference class</summary>
        </member>
        <member name="M:Nuclex.Support.WeakReferenceTest.TestSimpleConstructor">
            <summary>Tests whether the simple constructor works</summary>
        </member>
        <member name="M:Nuclex.Support.WeakReferenceTest.TestFullConstructor">
            <summary>Test whether the full constructor works</summary>
        </member>
        <member name="M:Nuclex.Support.WeakReferenceTest.TestTargetRetrieval">
            <summary>
              Test whether the target object can be retrieved from the weak reference
            </summary>
        </member>
        <member name="M:Nuclex.Support.WeakReferenceTest.TestTargetReassignment">
            <summary>
              Test whether the target object can be reassigned in the weak reference
            </summary>
        </member>
        <member name="M:Nuclex.Support.WeakReferenceTest.TestSerialization">
            <summary>
              Test whether the target object can be reassigned in the weak reference
            </summary>
        </member>
        <member name="T:Nuclex.Support.WeakReferenceTest.Dummy">
            <summary>Dummy class for testing the shared instance provider</summary>
        </member>
        <member name="M:Nuclex.Support.WeakReferenceTest.Dummy.#ctor">
            <summary>Initializes a new dummy</summary>
        </member>
        <member name="T:Nuclex.Support.SharedTest">
            <summary>Unit Test for the shared instance provider class</summary>
        </member>
        <member name="M:Nuclex.Support.SharedTest.TestSameInstance">
            <summary>
              Verifies that the shared instance provider returns the same instance of a class
              when asked for the same class twice.
            </summary>
        </member>
        <member name="T:Nuclex.Support.SharedTest.Dummy">
            <summary>Dummy class for testing the shared instance provider</summary>
        </member>
        <member name="M:Nuclex.Support.SharedTest.Dummy.#ctor">
            <summary>Initializes a new dummy</summary>
        </member>
        <member name="T:Nuclex.Support.PathHelper">
            <summary>Utility class for path operations</summary>
        </member>
        <member name="M:Nuclex.Support.PathHelper.MakeRelative(System.String,System.String)">
            <summary>Converts an absolute path into a relative one</summary>
            <param name="basePath">Base directory the new path should be relative to</param>
            <param name="absolutePath">Absolute path that will be made relative</param>
            <returns>
              A path relative to the indicated base directory that matches the
              absolute path given.
            </returns>
        </member>
        <member name="T:Nuclex.Support.Licensing.LicenseKey">
            <summary>Typical license key with 5x5 alphanumerical characters</summary>
            <remarks>
              <para>
                This class manages a license key like it is used in Microsoft products.
                Althought it is probably not the exact same technique used by Microsoft,
                the textual representation of the license keys looks identical,
                eg. <code>O809J-RN5TD-IM3CU-4IG1O-O90X9</code>.
              </para>
              <para>
                Available storage space is used efficiently and allows for up to four
                32 bit integers to be stored within the key, that's enough for a full GUID.
                The four integers can be modified directly, for example to store feature
                lists, checksums or other data within the key.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.Parse(System.String)">
            <summary>Parses the license key contained in a string</summary>
            <param name="key">String containing a license key that is to be parsed</param>
            <returns>The license key parsed from provided string</returns>
            <exception cref="T:System.ArgumentException">
              When the provided string is not a license key
            </exception>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.#ctor">
            <summary>Initializes a new, empty license key</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.#ctor(System.Guid)">
            <summary>Initializes the license key from a GUID</summary>
            <param name="source">GUID that is used to create the license key</param>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.ToGuid">
            <summary>Converts the license key into a GUID</summary>
            <returns>The GUID created from the license key</returns>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.ToByteArray">
            <summary>Converts the license key into a byte array</summary>
            <returns>A byte array containing the converted license key</returns>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.ToString">
            <summary>Converts the license key to a string</summary>
            <returns>A string containing the converted license key</returns>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.mangle(System.Collections.BitArray)">
            <summary>Mangles a bit array</summary>
            <param name="bits">Bit array that will be mangled</param>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.unmangle(System.Collections.BitArray)">
            <summary>Unmangles a bit array</summary>
            <param name="bits">Bit array that will be unmangled</param>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.keyDelimiter">
            <summary>Character used to delimit each 5 digit group in a license key</summary>
            <remarks>
              Required to be a char array because the .NET Compact Framework only provides
              an overload for char[] in the StringBuilder.Insert() method.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.codeTable">
            <summary>Table with the individual characters in a key</summary>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.powersOfTwo">
            <summary>Helper array containing the precalculated powers of two</summary>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.shuffle">
            <summary>Index list for rotating the bit arrays</summary>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.guid">
            <summary>GUID in which the key is stored</summary>
        </member>
        <member name="P:Nuclex.Support.Licensing.LicenseKey.Item(System.Int32)">
            <summary>Accesses the four integer values within a license key</summary>
            <exception cref="T:System.IndexOutOfRangeException">
              When the index lies outside of the key's fields
            </exception>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableSetTest">
            <summary>Unit Test for the observable set wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.HasDefaultConstructor">
            <summary>
              Verifies that the observable set has a default constructor
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.AddingItemsTriggersEvent">
            <summary>
              Verifies that adding items to the set triggers the 'ItemAdded' event
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.RemovingItemsTriggersEvent">
            <summary>
              Verifies that removing items from the set triggers the 'ItemRemoved' event
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.AddingAlreadyContainedItemDoesNotTriggerEvent">
            <summary>
              Verifies that adding items to the set triggers the 'ItemAdded' event
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.ExceptWithSelfEmptiesSet">
            <summary>
              Verifies that excepting the set with itself empties the set
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.SetCanBeExceptedWithCollection">
            <summary>
              Verifies that a set can be excepted with a collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.SetCanBeIntersectedWithCollection">
            <summary>
              Verifies that a set can be intersected with a collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.CanDetermineProperSubsetAndSuperset">
            <summary>
              Verifies that it's possible to determine whether a set is a proper subset
              or superset of another set
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.CanDetermineSubsetAndSuperset">
            <summary>
              Verifies that it's possible to determine whether a set is a subset
              or a superset of another set
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.CanDetermineOverlap">
            <summary>
              Verifies that a set can determine if another set overlaps with it
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.CanDetermineSetEquality">
            <summary>
              Verifies that a set can determine if another set contains the same elements
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.CanBeSymmetricallyExcepted">
            <summary>
              Verifies that a set can be symmetrically excepted with another set
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.CanBeUnioned">
            <summary>
              Verifies that a union of two sets can be built
            </summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableSetTest.mockFactory">
            <summary>Creates mock object for the test</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableSetTest.observableSet">
            <summary>Observable set being tested</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableSetTest.subscriber">
            <summary>Subscriber for the observable set's events</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.IObservableCollectionSubscriber`1.ItemAdded(System.Object,Nuclex.Support.Collections.ItemEventArgs{`0})">
            <summary>Called when an item has been added to the collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.IObservableCollectionSubscriber`1.ItemRemoved(System.Object,Nuclex.Support.Collections.ItemEventArgs{`0})">
            <summary>Called when an item is removed from the collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.IObservableCollectionSubscriber`1.ItemReplaced(System.Object,Nuclex.Support.Collections.ItemReplaceEventArgs{`0})">
            <summary>Called when an item is replaced in the collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.IObservableCollectionSubscriber`1.Clearing(System.Object,System.EventArgs)">
            <summary>Called when the collection is about to be cleared</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableSetTest.IObservableCollectionSubscriber`1.Cleared(System.Object,System.EventArgs)">
            <summary>Called when the collection has been cleared</summary>
        </member>
        <member name="T:Nuclex.Support.WeakReference`1">
            <summary>
              Type-safe weak reference, referencing an object while still allowing
              that object to be garbage collected.
            </summary>
        </member>
        <member name="M:Nuclex.Support.WeakReference`1.#ctor(`0)">
            <summary>
              Initializes a new instance of the WeakReference class, referencing
              the specified object.
            </summary>
            <param name="target">The object to track or null.</param>
        </member>
        <member name="M:Nuclex.Support.WeakReference`1.#ctor(`0,System.Boolean)">
            <summary>
              Initializes a new instance of the WeakReference class, referencing
              the specified object optionally using resurrection tracking.
            </summary>
            <param name="target">An object to track.</param>
            <param name="trackResurrection">
              Indicates when to stop tracking the object. If true, the object is tracked
              after finalization; if false, the object is only tracked until finalization.
            </param>
        </member>
        <member name="M:Nuclex.Support.WeakReference`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the WeakReference class, using deserialized
              data from the specified serialization and stream objects.
            </summary>
            <param name="info">
              An object that holds all the data needed to serialize or deserialize the
              current System.WeakReference object.
            </param>
            <param name="context">
              (Reserved) Describes the source and destination of the serialized stream
              specified by info.
            </param>
            <exception cref="T:System.ArgumentNullException">
              The info parameter is null.
            </exception>
        </member>
        <member name="P:Nuclex.Support.WeakReference`1.Target">
            <summary>
              Gets or sets the object (the target) referenced by the current WeakReference
              object.
            </summary>
            <remarks>
              Is null if the object referenced by the current System.WeakReference object
              has been garbage collected; otherwise, a reference to the object referenced
              by the current System.WeakReference object.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
              The reference to the target object is invalid. This can occur if the current
              System.WeakReference object has been finalized
            </exception>
        </member>
        <member name="T:Nuclex.Support.StringHelper">
            <summary>Helper routines for working with strings</summary>
        </member>
        <member name="M:Nuclex.Support.StringHelper.IndexNotOfAny(System.String,System.Char[])">
            <summary>
              Searches for the first occurence of a character other than the characters
              listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.IndexNotOfAny(System.String,System.Char[],System.Int32)">
            <summary>
              Searches for the first occurence of a character other than the characters
              listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <param name="startIndex">
              Index of the character in the haystack at which to start scanning
            </param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.IndexNotOfAny(System.String,System.Char[],System.Int32,System.Int32)">
            <summary>
              Searches for the first occurence of a character other than the characters
              listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <param name="startIndex">
              Index of the character in the haystack at which to start scanning
            </param>
            <param name="count">Number of characters in the haystack to scan</param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.LastIndexNotOfAny(System.String,System.Char[])">
            <summary>
              Searches backwards for the first occurence of a character other than the
              characters listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.LastIndexNotOfAny(System.String,System.Char[],System.Int32)">
            <summary>
              Searches backwards for the first occurence of a character other than the
              characters listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <param name="startIndex">
              Index of the character in the haystack at which to start scanning
            </param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.LastIndexNotOfAny(System.String,System.Char[],System.Int32,System.Int32)">
            <summary>
              Searches backwards for the first occurence of a character other than the
              characters listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <param name="startIndex">
              Index of the character in the haystack at which to start scanning
            </param>
            <param name="count">Number of characters in the haystack to scan</param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="T:Nuclex.Support.ObservableHelperTest">
            <summary>Unit tests for the observable helper</summary>
        </member>
        <member name="M:Nuclex.Support.ObservableHelperTest.CanObtainPropertyNameFromLambdaExpression">
            <summary>
              Verifies that the name of a property accessed in a lambda expression
              can be obtained.
            </summary>
        </member>
        <member name="M:Nuclex.Support.ObservableHelperTest.CanObtainPropertyNameFromBoxedLambdaExpression">
            <summary>
              Verifies that the name of a property assigned in a lambda expression
              can be obtained.
            </summary>
        </member>
        <member name="P:Nuclex.Support.ObservableHelperTest.SomeReferenceType">
            <summary>Helper used to construct lambda expressions</summary>
        </member>
        <member name="P:Nuclex.Support.ObservableHelperTest.SomeValueType">
            <summary>Helper used to construct lambda expressions</summary>
        </member>
        <member name="T:Nuclex.Support.ObservableHelperTest.TestReferenceType">
            <summary>Example class on which unit test generates change notifications</summary>
        </member>
        <member name="P:Nuclex.Support.ObservableHelperTest.TestReferenceType.SomeProperty">
            <summary>Example property that will be reported to have changed</summary>
        </member>
        <member name="T:Nuclex.Support.ObservableHelperTest.TestValueType">
            <summary>Example class on which unit test generates change notifications</summary>
        </member>
        <member name="P:Nuclex.Support.ObservableHelperTest.TestValueType.SomeProperty">
            <summary>Example property that will be reported to have changed</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PairPriorityQueue`2">
            <summary>Queue that dequeues items in order of their priority</summary>
            <remarks>
              This variant of the priority queue uses an external priority value. If the
              priority data type implements the IComparable interface, the user does not
              even
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.#ctor">
            <summary>Initializes a new non-intrusive priority queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>Initializes a new non-intrusive priority queue</summary>
            <param name="priorityComparer">Comparer used to compare the item priorities</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.Peek">
            <summary>Returns the topmost item in the queue without dequeueing it</summary>
            <returns>The topmost item in the queue</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.Dequeue">
            <summary>Takes the item with the highest priority off from the queue</summary>
            <returns>The item with the highest priority in the list</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.Enqueue(`0,`1)">
            <summary>Puts an item into the priority queue</summary>
            <param name="priority">Priority of the item to be queued</param>
            <param name="item">Item to be queued</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.Clear">
            <summary>Removes all items from the priority queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the priority queue into an array</summary>
            <param name="array">Array to copy the priority queue into</param>
            <param name="index">Starting index for the destination array</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.GetEnumerator">
            <summary>Returns a typesafe enumerator for the priority queue</summary>
            <returns>A new enumerator for the priority queue</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator for the priority queue</summary>
            <returns>A new enumerator for the priority queue</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.PairPriorityQueue`2.internalQueue">
            <summary>Intrusive priority queue being wrapped by this class</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PairPriorityQueue`2.Count">
            <summary>Total number of items in the priority queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PairPriorityQueue`2.SyncRoot">
            <summary>
              Obtains an object that can be used to synchronize accesses to the priority queue
              from different threads
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PairPriorityQueue`2.IsSynchronized">
            <summary>Whether operations performed on this priority queue are thread safe</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PairPriorityQueue`2.PairComparer">
            <summary>Compares two priority queue entries based on their priority</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.PairComparer.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>Initializes a new entry comparer</summary>
            <param name="priorityComparer">Comparer used to compare entry priorities</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.PairComparer.Compare(Nuclex.Support.Collections.PriorityItemPair{`0,`1},Nuclex.Support.Collections.PriorityItemPair{`0,`1})">
            <summary>Compares the left entry to the right entry</summary>
            <param name="left">Entry on the left side</param>
            <param name="right">Entry on the right side</param>
            <returns>The relationship of the two entries</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.PairPriorityQueue`2.PairComparer.priorityComparer">
            <summary>Comparer used to compare the priorities of the entries</summary>
        </member>
    </members>
</doc>
